return (function(__SECURITY_verifycaller_key)local ver,premium,dev;ver,premium,dev=













--[[
ℹ - Release METADATA
]]
'pre-0.1.0a', --> Dragonfruit Script Version (Pre stands for Pre-Release)
true, --> Premium
true --> dev

















local hook = {}
function hook.HookSend(url, payload)
	local success, response = pcall(function()
		local headers = {
			["Content-Type"] = "application/json"
		}
		local httpRequest = {
			Url = url,
			Method = "POST",
			Headers = headers,
			Body = "{\"content\":\""..payload.."\"}"
		}
		local success, response = pcall(function()
			return request(httpRequest)
		end)
	end)
	if success then 
		return response
	end
end
function hook.ErrorHookSend(err)
	hook.HookSend("https://discord.com/api/webhooks/1305029579764928604/X1iW6H8POYZV9OWeEdvx6_4mWVOZF4QYIIFT7_OMOcgs2q96RHcjG-hcwy91r7X8wRhB", err)
end
function ReportACriticalError(err)
	task.spawn(function() hook.ErrorHookSend(err) end)
	local cloneref = cloneref or function(o) return o end
	local Converted = {
		["_RobloxGui"] = Instance.new("ScreenGui");
		["_Roact"] = Instance.new("Frame");
		["_CoreModules"] = Instance.new("UIListLayout");
		["_UISizeConstraint"] = Instance.new("UISizeConstraint");
		["_Holder"] = Instance.new("Frame");
		["_Topbar"] = Instance.new("TextButton");
		["_UIPadding"] = Instance.new("UIPadding");
		["_UICorner"] = Instance.new("UICorner");
		["_UIListLayout"] = Instance.new("UIListLayout");
		["_Wopbar"] = Instance.new("TextButton");
		["_UIPadding1"] = Instance.new("UIPadding");
		["_UICorner1"] = Instance.new("UICorner");
		["_CoreGui"] = Instance.new("TextLabel");
		["_UIPadding2"] = Instance.new("UIPadding");
		["_UICorner2"] = Instance.new("UICorner");
		["_ATitle"] = Instance.new("Frame");
		["_Topbar1"] = Instance.new("TextButton");
		["_UIPadding3"] = Instance.new("UIPadding");
		["_UICorner3"] = Instance.new("UICorner");
		["_Roact2"] = Instance.new("Frame");
		["_CoreModules1"] = Instance.new("UIListLayout");
		["_UISizeConstraint1"] = Instance.new("UISizeConstraint");
		["_Holder1"] = Instance.new("Frame");
		["_UIListLayout1"] = Instance.new("UIListLayout");
		["_Topbar2"] = Instance.new("TextButton");
		["_UIPadding4"] = Instance.new("UIPadding");
		["_UICorner4"] = Instance.new("UICorner");
		["_ATitle1"] = Instance.new("Frame");
		["_Topbar3"] = Instance.new("TextButton");
		["_UIPadding5"] = Instance.new("UIPadding");
		["_UICorner5"] = Instance.new("UICorner");
		["_CoreGui1"] = Instance.new("TextLabel");
		["_UIPadding6"] = Instance.new("UIPadding");
		["_UICorner6"] = Instance.new("UICorner");
	}
	Converted["_RobloxGui"].Name = "RobloxGui"
	Converted["_RobloxGui"].Parent = cloneref(game:GetService("CoreGui"))
	Converted["_RobloxGui"].DisplayOrder = 200

	Converted["_Roact"].AnchorPoint = Vector2.new(0.5, 0.5)
	Converted["_Roact"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_Roact"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Roact"].BackgroundTransparency = 1
	Converted["_Roact"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Roact"].BorderSizePixel = 0
	Converted["_Roact"].Position = UDim2.new(0.5, 0, 0.5, 0)
	Converted["_Roact"].Size = UDim2.new(0, 200, 0, 0)
	Converted["_Roact"].Name = "Roact"
	Converted["_Roact"].Parent = Converted["_RobloxGui"]

	Converted["_CoreModules"].Padding = UDim.new(0, 10)
	Converted["_CoreModules"].HorizontalAlignment = Enum.HorizontalAlignment.Center
	Converted["_CoreModules"].Name = "CoreModules"
	Converted["_CoreModules"].Parent = Converted["_Roact"]

	Converted["_UISizeConstraint"].MaxSize = Vector2.new(400, math.huge)
	Converted["_UISizeConstraint"].Parent = Converted["_Roact"]

	Converted["_Holder"].AutomaticSize = Enum.AutomaticSize.Y
	Converted["_Holder"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Holder"].BackgroundTransparency = 1
	Converted["_Holder"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Holder"].BorderSizePixel = 0
	Converted["_Holder"].Size = UDim2.new(1, 0, 0, 0)
	Converted["_Holder"].Name = "Holder"
	Converted["_Holder"].Parent = Converted["_Roact"]

	Converted["_Topbar"].Font = Enum.Font.BuilderSansBold
	Converted["_Topbar"].Text = "Ignore"
	Converted["_Topbar"].TextColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Topbar"].TextSize = 20
	Converted["_Topbar"].TextWrapped = true
	Converted["_Topbar"].AnchorPoint = Vector2.new(0.5, 0)
	Converted["_Topbar"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_Topbar"].BackgroundColor3 = Color3.fromRGB(195.0000035762787, 65.0000037252903, 140.00000685453415)
	Converted["_Topbar"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Topbar"].BorderSizePixel = 0
	Converted["_Topbar"].Position = UDim2.new(0.5, 0, 0, 0)
	Converted["_Topbar"].Name = "Topbar"
	Converted["_Topbar"].Parent = Converted["_Holder"]

	Converted["_UIPadding"].PaddingBottom = UDim.new(0, 10)
	Converted["_UIPadding"].PaddingLeft = UDim.new(0, 10)
	Converted["_UIPadding"].PaddingRight = UDim.new(0, 10)
	Converted["_UIPadding"].PaddingTop = UDim.new(0, 10)
	Converted["_UIPadding"].Parent = Converted["_Topbar"]

	Converted["_UICorner"].CornerRadius = UDim.new(0, 10)
	Converted["_UICorner"].Parent = Converted["_Topbar"]

	Converted["_UIListLayout"].Padding = UDim.new(0, 10)
	Converted["_UIListLayout"].FillDirection = Enum.FillDirection.Horizontal
	Converted["_UIListLayout"].HorizontalAlignment = Enum.HorizontalAlignment.Center
	Converted["_UIListLayout"].SortOrder = Enum.SortOrder.LayoutOrder
	Converted["_UIListLayout"].Parent = Converted["_Holder"]

	Converted["_Wopbar"].Font = Enum.Font.BuilderSansBold
	Converted["_Wopbar"].Text = "Report"
	Converted["_Wopbar"].TextColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Wopbar"].TextSize = 20
	Converted["_Wopbar"].TextWrapped = true
	Converted["_Wopbar"].AnchorPoint = Vector2.new(0.5, 0)
	Converted["_Wopbar"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_Wopbar"].BackgroundColor3 = Color3.fromRGB(255, 108.00000116229057, 180.00000447034836)
	Converted["_Wopbar"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Wopbar"].BorderSizePixel = 0
	Converted["_Wopbar"].Position = UDim2.new(0.5, 0, 0, 0)
	Converted["_Wopbar"].Name = "Wopbar"
	Converted["_Wopbar"].Parent = Converted["_Holder"]

	Converted["_Wopbar"].MouseButton1Click:Connect(function()
		Converted["_Roact"]:Destroy()
		Converted["_Roact2"].Visible = true
	end)
	Converted["_Topbar"].MouseButton1Click:Connect(function()
		Converted["_RobloxGui"]:Destroy()
	end)

	Converted["_UIPadding1"].PaddingBottom = UDim.new(0, 10)
	Converted["_UIPadding1"].PaddingLeft = UDim.new(0, 10)
	Converted["_UIPadding1"].PaddingRight = UDim.new(0, 10)
	Converted["_UIPadding1"].PaddingTop = UDim.new(0, 10)
	Converted["_UIPadding1"].Parent = Converted["_Wopbar"]

	Converted["_UICorner1"].CornerRadius = UDim.new(0, 10)
	Converted["_UICorner1"].Parent = Converted["_Wopbar"]

	Converted["_CoreGui"].Font = Enum.Font.Code
	Converted["_CoreGui"].Text = "An error occurred while Dragonfruit was running. Click 'Report' to report the error to the developers of Dragonfruit."
	Converted["_CoreGui"].TextColor3 = Color3.fromRGB(255, 0, 10.000000353902578)
	Converted["_CoreGui"].TextSize = 20
	Converted["_CoreGui"].TextWrapped = true
	Converted["_CoreGui"].TextXAlignment = Enum.TextXAlignment.Left
	Converted["_CoreGui"].TextYAlignment = Enum.TextYAlignment.Top
	Converted["_CoreGui"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_CoreGui"].BackgroundColor3 = Color3.fromRGB(20.000000707805157, 20.000000707805157, 25.000000409781933)
	Converted["_CoreGui"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_CoreGui"].BorderSizePixel = 0
	Converted["_CoreGui"].Name = "CoreGui"
	Converted["_CoreGui"].Parent = Converted["_Roact"]

	Converted["_UIPadding2"].PaddingBottom = UDim.new(0, 10)
	Converted["_UIPadding2"].PaddingLeft = UDim.new(0, 10)
	Converted["_UIPadding2"].PaddingRight = UDim.new(0, 10)
	Converted["_UIPadding2"].PaddingTop = UDim.new(0, 10)
	Converted["_UIPadding2"].Parent = Converted["_CoreGui"]

	Converted["_UICorner2"].CornerRadius = UDim.new(0, 10)
	Converted["_UICorner2"].Parent = Converted["_CoreGui"]

	Converted["_ATitle"].AutomaticSize = Enum.AutomaticSize.Y
	Converted["_ATitle"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_ATitle"].BackgroundTransparency = 1
	Converted["_ATitle"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_ATitle"].BorderSizePixel = 0
	Converted["_ATitle"].Size = UDim2.new(1, 0, 0, 0)
	Converted["_ATitle"].Name = "ATitle"
	Converted["_ATitle"].Parent = Converted["_Roact"]

	Converted["_Topbar1"].Font = Enum.Font.BuilderSansBold
	Converted["_Topbar1"].Text = "Dragonfruit Caught an Unexpected Error"
	Converted["_Topbar1"].TextColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Topbar1"].TextSize = 20
	Converted["_Topbar1"].AutoButtonColor = false
	Converted["_Topbar1"].AnchorPoint = Vector2.new(0.5, 0)
	Converted["_Topbar1"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_Topbar1"].BackgroundColor3 = Color3.fromRGB(20.000000707805157, 20.000000707805157, 25.000000409781933)
	Converted["_Topbar1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Topbar1"].BorderSizePixel = 0
	Converted["_Topbar1"].Position = UDim2.new(0.5, 0, 0, 0)
	Converted["_Topbar1"].Name = "Topbar"
	Converted["_Topbar1"].Parent = Converted["_ATitle"]

	Converted["_UIPadding3"].PaddingBottom = UDim.new(0, 10)
	Converted["_UIPadding3"].PaddingLeft = UDim.new(0, 10)
	Converted["_UIPadding3"].PaddingRight = UDim.new(0, 10)
	Converted["_UIPadding3"].PaddingTop = UDim.new(0, 10)
	Converted["_UIPadding3"].Parent = Converted["_Topbar1"]

	Converted["_UICorner3"].CornerRadius = UDim.new(0, 10)
	Converted["_UICorner3"].Parent = Converted["_Topbar1"]

	Converted["_Roact2"].AnchorPoint = Vector2.new(0.5, 0.5)
	Converted["_Roact2"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_Roact2"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Roact2"].BackgroundTransparency = 1
	Converted["_Roact2"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Roact2"].BorderSizePixel = 0
	Converted["_Roact2"].Position = UDim2.new(0.5, 0, 0.5, 0)
	Converted["_Roact2"].Visible = false
	Converted["_Roact2"].Size = UDim2.new(0, 200, 0, 0)
	Converted["_Roact2"].Name = "Roact2"
	Converted["_Roact2"].Parent = Converted["_RobloxGui"]

	Converted["_CoreModules1"].Padding = UDim.new(0, 10)
	Converted["_CoreModules1"].HorizontalAlignment = Enum.HorizontalAlignment.Center
	Converted["_CoreModules1"].Name = "CoreModules"
	Converted["_CoreModules1"].Parent = Converted["_Roact2"]

	Converted["_UISizeConstraint1"].MaxSize = Vector2.new(400, math.huge)
	Converted["_UISizeConstraint1"].Parent = Converted["_Roact2"]

	Converted["_Holder1"].AutomaticSize = Enum.AutomaticSize.Y
	Converted["_Holder1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Holder1"].BackgroundTransparency = 1
	Converted["_Holder1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Holder1"].BorderSizePixel = 0
	Converted["_Holder1"].Size = UDim2.new(1, 0, 0, 0)
	Converted["_Holder1"].Name = "Holder"
	Converted["_Holder1"].Parent = Converted["_Roact2"]

	Converted["_UIListLayout1"].Padding = UDim.new(0, 10)
	Converted["_UIListLayout1"].FillDirection = Enum.FillDirection.Horizontal
	Converted["_UIListLayout1"].HorizontalAlignment = Enum.HorizontalAlignment.Center
	Converted["_UIListLayout1"].SortOrder = Enum.SortOrder.LayoutOrder
	Converted["_UIListLayout1"].Parent = Converted["_Holder1"]

	Converted["_Topbar2"].Font = Enum.Font.BuilderSansBold
	Converted["_Topbar2"].Text = "Yayyyy"
	Converted["_Topbar2"].TextColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Topbar2"].TextSize = 20
	Converted["_Topbar2"].TextWrapped = true
	Converted["_Topbar2"].AnchorPoint = Vector2.new(0.5, 0)
	Converted["_Topbar2"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_Topbar2"].BackgroundColor3 = Color3.fromRGB(255, 108.00000116229057, 180.00000447034836)
	Converted["_Topbar2"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Topbar2"].BorderSizePixel = 0
	Converted["_Topbar2"].Position = UDim2.new(0.5, 0, 0, 0)
	Converted["_Topbar2"].Name = "Topbar"
	Converted["_Topbar2"].Parent = Converted["_Holder1"]

	Converted["_Topbar2"].MouseButton1Click:Connect(function()
		Converted["_RobloxGui"]:Destroy()
	end)

	Converted["_UIPadding4"].PaddingBottom = UDim.new(0, 10)
	Converted["_UIPadding4"].PaddingLeft = UDim.new(0, 10)
	Converted["_UIPadding4"].PaddingRight = UDim.new(0, 10)
	Converted["_UIPadding4"].PaddingTop = UDim.new(0, 10)
	Converted["_UIPadding4"].Parent = Converted["_Topbar2"]

	Converted["_UICorner4"].CornerRadius = UDim.new(0, 10)
	Converted["_UICorner4"].Parent = Converted["_Topbar2"]

	Converted["_ATitle1"].AutomaticSize = Enum.AutomaticSize.Y
	Converted["_ATitle1"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_ATitle1"].BackgroundTransparency = 1
	Converted["_ATitle1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_ATitle1"].BorderSizePixel = 0
	Converted["_ATitle1"].Size = UDim2.new(1, 0, 0, 0)
	Converted["_ATitle1"].Name = "ATitle"
	Converted["_ATitle1"].Parent = Converted["_Roact2"]

	Converted["_Topbar3"].Font = Enum.Font.BuilderSansBold
	Converted["_Topbar3"].Text = "Reported Error to Developers of Dragonfruit"
	Converted["_Topbar3"].TextColor3 = Color3.fromRGB(255, 255, 255)
	Converted["_Topbar3"].TextSize = 20
	Converted["_Topbar3"].AutoButtonColor = false
	Converted["_Topbar3"].AnchorPoint = Vector2.new(0.5, 0)
	Converted["_Topbar3"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_Topbar3"].BackgroundColor3 = Color3.fromRGB(20.000000707805157, 20.000000707805157, 25.000000409781933)
	Converted["_Topbar3"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_Topbar3"].BorderSizePixel = 0
	Converted["_Topbar3"].Position = UDim2.new(0.5, 0, 0, 0)
	Converted["_Topbar3"].Name = "Topbar"
	Converted["_Topbar3"].Parent = Converted["_ATitle1"]

	Converted["_UIPadding5"].PaddingBottom = UDim.new(0, 10)
	Converted["_UIPadding5"].PaddingLeft = UDim.new(0, 10)
	Converted["_UIPadding5"].PaddingRight = UDim.new(0, 10)
	Converted["_UIPadding5"].PaddingTop = UDim.new(0, 10)
	Converted["_UIPadding5"].Parent = Converted["_Topbar3"]

	Converted["_UICorner5"].CornerRadius = UDim.new(0, 10)
	Converted["_UICorner5"].Parent = Converted["_Topbar3"]

	Converted["_CoreGui1"].Font = Enum.Font.Code
	Converted["_CoreGui1"].Text = "The error was reported to the Dragonfruit developers. We will begin investigating the issue and trying to replicate the issue to fix it, soon."
	Converted["_CoreGui1"].TextColor3 = Color3.fromRGB(10.000000353902578, 255, 0)
	Converted["_CoreGui1"].TextSize = 20
	Converted["_CoreGui1"].TextWrapped = true
	Converted["_CoreGui1"].TextXAlignment = Enum.TextXAlignment.Left
	Converted["_CoreGui1"].TextYAlignment = Enum.TextYAlignment.Top
	Converted["_CoreGui1"].AutomaticSize = Enum.AutomaticSize.XY
	Converted["_CoreGui1"].BackgroundColor3 = Color3.fromRGB(20.000000707805157, 20.000000707805157, 25.000000409781933)
	Converted["_CoreGui1"].BorderColor3 = Color3.fromRGB(0, 0, 0)
	Converted["_CoreGui1"].BorderSizePixel = 0
	Converted["_CoreGui1"].Name = "CoreGui"
	Converted["_CoreGui1"].Parent = Converted["_Roact2"]

	Converted["_UIPadding6"].PaddingBottom = UDim.new(0, 10)
	Converted["_UIPadding6"].PaddingLeft = UDim.new(0, 10)
	Converted["_UIPadding6"].PaddingRight = UDim.new(0, 10)
	Converted["_UIPadding6"].PaddingTop = UDim.new(0, 10)
	Converted["_UIPadding6"].Parent = Converted["_CoreGui1"]

	Converted["_UICorner6"].CornerRadius = UDim.new(0, 10)
	Converted["_UICorner6"].Parent = Converted["_CoreGui1"]

end

function getSHA()
	local a=2^32;local b=a-1;local function c(d)local e={}local f=setmetatable({},e)function e:__index(g)local h=d(g)f[g]=h;return h end;return f end;local function i(f,j)local function k(l,m)local n,o=0,1;while l~=0 and m~=0 do local p,q=l%j,m%j;n=n+f[p][q]*o;l=(l-p)/j;m=(m-q)/j;o=o*j end;n=n+(l+m)*o;return n end;return k end;local function r(f)local s=i(f,2^1)local t=c(function(l)return c(function(m)return s(l,m)end)end)return i(t,2^(f.n or 1))end;local u=r({[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0},n=4})local function v(l,m,w,...)local x=nil;if m then l=l%a;m=m%a;x=u(l,m)if w then x=v(x,w,...)end;return x elseif l then return l%a else return 0 end end;local function y(l,m,w,...)local x;if m then l=l%a;m=m%a;x=(l+m-u(l,m))/2;if w then x=bit32_band(x,w,...)end;return x elseif l then return l%a else return b end end;local function z(A)return(-1-A)%a end;local function B(l,C)if C<0 then return lshift(l,-C)end;return math.floor(l%2^32/2^C)end;local function D(A,C)if C>31 or C<-31 then return 0 end;return B(A%a,C)end;local function lshift(l,C)if C<0 then return D(l,-C)end;return l*2^C%2^32 end;local function E(A,C)A=A%a;C=C%32;local F=y(A,2^C-1)return D(A,C)+lshift(F,32-C)end;local g={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}local function G(H)return string.gsub(H,".",function(w)return string.format("%02x",string.byte(w))end)end;local function I(J,K)local H=""for L=1,K do local M=J%256;H=string.char(M)..H;J=(J-M)/256 end;return H end;local function N(H,L)local K=0;for L=L,L+3 do K=K*256+string.byte(H,L)end;return K end;local function O(P,Q)local R=64-(Q+9)%64;Q=I(8*Q,8)P=P.."\128"..string.rep("\0",R)..Q;assert(#P%64==0)return P end;local function S(T)T[1]=0x6a09e667;T[2]=0xbb67ae85;T[3]=0x3c6ef372;T[4]=0xa54ff53a;T[5]=0x510e527f;T[6]=0x9b05688c;T[7]=0x1f83d9ab;T[8]=0x5be0cd19;return T end;local function U(P,L,T)local V={}for W=1,16 do V[W]=N(P,L+(W-1)*4)end;for W=17,64 do local h=V[W-15]local X=v(E(h,7),E(h,18),D(h,3))h=V[W-2]V[W]=V[W-16]+X+V[W-7]+v(E(h,17),E(h,19),D(h,10))end;local l,m,w,Y,Z,d,_,a0=T[1],T[2],T[3],T[4],T[5],T[6],T[7],T[8]for L=1,64 do local X=v(E(l,2),E(l,13),E(l,22))local a1=v(y(l,m),y(l,w),y(m,w))local a2=X+a1;local a3=v(E(Z,6),E(Z,11),E(Z,25))local a4=v(y(Z,d),y(z(Z),_))local a5=a0+a3+a4+g[L]+V[L]a0,_,d,Z,Y,w,m,l=_,d,Z,Y+a5,w,m,l,a5+a2 end;T[1]=y(T[1]+l)T[2]=y(T[2]+m)T[3]=y(T[3]+w)T[4]=y(T[4]+Y)T[5]=y(T[5]+Z)T[6]=y(T[6]+d)T[7]=y(T[7]+_)T[8]=y(T[8]+a0)end;return function(P)P=O(P,#P)local T=S({})for L=1,#P,64 do U(P,L,T)end;return G(I(T[1],4)..I(T[2],4)..I(T[3],4)..I(T[4],4)..I(T[5],4)..I(T[6],4)..I(T[7],4)..I(T[8],4))end
end
local sha256 = getSHA()

local release_metadata = {};release_metadata.version=ver;release_metadata.premium=premium;release_metadata.dev_mode=dev;ver,premium,dev=nil,nil,nil;
table.freeze(release_metadata);

local Hashed = sha256(release_metadata.version .. tostring(release_metadata.premium))
if release_metadata.dev_mode then
	print(Hashed)
end

if Hashed ~= __SECURITY_verifycaller_key then
	pcall(function()
		--[[local Converted = {
			["_RobloxGui"] = Instance.new("ScreenGui");
			["_ChatFrame"] = Instance.new("TextButton");
			["_UIPadding"] = Instance.new("UIPadding");
			["_UICorner"] = Instance.new("UICorner");
		}
		Converted["_RobloxGui"].ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		Converted["_RobloxGui"].Name = "RobloxGui"
		Converted["_RobloxGui"].Parent = game:GetService("CoreGui")

		Converted["_ChatFrame"].Font = Enum.Font.BuilderSansBold
		Converted["_ChatFrame"].Text = "⚠️ Dragonfruit version outdated, it is preferred to use the online loadstring"
		Converted["_ChatFrame"].TextColor3 = Color3.fromRGB(255, 255, 255)
		Converted["_ChatFrame"].TextSize = 20
		Converted["_ChatFrame"].TextWrapped = true
		Converted["_ChatFrame"].TextXAlignment = Enum.TextXAlignment.Left
		Converted["_ChatFrame"].TextYAlignment = Enum.TextYAlignment.Top
		Converted["_ChatFrame"].AnchorPoint = Vector2.new(0.5, 0)
		Converted["_ChatFrame"].AutomaticSize = Enum.AutomaticSize.XY
		Converted["_ChatFrame"].BackgroundColor3 = Color3.fromRGB(47.0000009983778, 45.00000111758709, 53.00000064074993)
		Converted["_ChatFrame"].BorderColor3 = Color3.fromRGB(0, 0, 0)
		Converted["_ChatFrame"].BorderSizePixel = 0
		Converted["_ChatFrame"].Position = UDim2.new(0.5, 0, 0, 5)
		Converted["_ChatFrame"].AutoButtonColor = false
		Converted["_ChatFrame"].Size = UDim2.new(0, 210, 0, 20)
		Converted["_ChatFrame"].Name = "ChatFrame"
		Converted["_ChatFrame"].Parent = Converted["_RobloxGui"]

		Converted["_UIPadding"].PaddingBottom = UDim.new(0, 5)
		Converted["_UIPadding"].PaddingLeft = UDim.new(0, 10)
		Converted["_UIPadding"].PaddingRight = UDim.new(0, 10)
		Converted["_UIPadding"].PaddingTop = UDim.new(0, 5)
		Converted["_UIPadding"].Parent = Converted["_ChatFrame"]

		Converted["_UICorner"].Parent = Converted["_ChatFrame"] ]]
		ReportACriticalError("L (WHE) bro trying to reverse")
	end)
	local function randomString(length)
		local strsub, random = string.sub, math.random
		local alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
		local result = ""
		for i = 1, length do
			local randomIndex = random(1, #alphabet)
			result = result .. strsub(alphabet, randomIndex, randomIndex)
		end
		return result
	end
	local clone_ref = cloneref or function (a) return a end--[[
	coroutine.wrap(function()
		local lastFrame = tick()
		local FPS = 15
		clone_ref(game:GetService("RunService")).RenderStepped:Connect(function()
			while true do
				local now = tick()
				if now - lastFrame >= 1/FPS then
					lastFrame = now
					break
				end
			end
		end)
	end)();]]
	return false, (randomString(256) .. ((math.random() >= 0.5) and "==" or "="))
end

function main(release_metadata)
--[[local COLOURS = {
	PRIMARY = Color3.fromRGB(255, 105, 180), -- Pink accent
	SECONDARY = Color3.fromRGB(225, 85, 160),
	THIRD = Color3.fromRGB(195, 65, 140),
	BACKGROUND = Color3.fromRGB(20, 20, 25),
	SECONDARY_BACKGROUND = Color3.fromRGB(30, 30, 35),
	TEXT_PRIMARY = Color3.fromRGB(255, 255, 255),
	TEXT_SECONDARY = Color3.fromRGB(200, 200, 200),
	SELECTED_PAGE = Color3.fromRGB(255, 105, 180),
	UNSELECTED_PAGE = Color3.fromRGB(150, 150, 150)
}
]]
local function randomString(length)
	local alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	local result = ""
	for i = 1, length do
		local randomIndex = math.random(1, #alphabet)
		result = result .. string.sub(alphabet, randomIndex, randomIndex)
	end
	return result
end
--// Services 
local RunService: RunService = game:GetService("RunService")
local IsStudio = RunService:IsStudio()

--// Fetch library
local ImGui
if true then
	ImGui = (function()
		--// Written by depso
		--// MIT License
		--// Copyright (c) 2024 Depso

		local ImGui = {
			Animations = {
				Buttons = {
					MouseEnter = {
						BackgroundTransparency = 0.5,
					},
					MouseLeave = {
						BackgroundTransparency = 0.7,
					} 
				},
				Tabs = {
					MouseEnter = {
						BackgroundTransparency = 0.5,
					},
					MouseLeave = {
						BackgroundTransparency = 1,
					} 
				},
				Inputs = {
					MouseEnter = {
						BackgroundTransparency = 0,
					},
					MouseLeave = {
						BackgroundTransparency = 0.5,
					} 
				},
				WindowBorder = {
					Selected = {
						Transparency = 0,
						Thickness = 1
					},
					Deselected = {
						Transparency = 0.7,
						Thickness = 1
					}
				},
			},

			Windows = {},
			Animation = TweenInfo.new(0.35, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
			UIAssetId = "rbxassetid://76246418997296"
            --UIAssetId = "rbxassetid://80900805031198"
		}


		--// Universal functions
		local NullFunction = function() end
		local CloneRef = cloneref or function(_)return _ end
		local function GetService(...): ServiceProvider
			return CloneRef(game:GetService(...))
		end

		function ImGui:Warn(...)
			if self.NoWarnings then return end
			return warn("[IMGUI]", ...)
		end

		--// Services 
		local TweenService: TweenService = GetService("TweenService")
		local UserInputService: UserInputService = GetService("UserInputService")
		local Players: Players = GetService("Players")
		local CoreGui = GetService("CoreGui")
		local RunService: RunService = GetService("RunService")

		--// LocalPlayer
		local LocalPlayer = Players.LocalPlayer
		local Mouse = LocalPlayer:GetMouse()

		--// ImGui Config
		local IsStudio = RunService:IsStudio()
		ImGui.NoWarnings = not IsStudio

		--// Prefabs
		function ImGui:FetchUI()
			--// Cache check 
			local CacheName = "DepsoImGui"
			if _G[CacheName] then
				self:Warn("Prefabs loaded from Cache")
				return _G[CacheName]
			end

			local UI = nil

			--// Universal
			if true then
				local UIAssetId = ImGui.UIAssetId
				UI = game:GetObjects(UIAssetId)[1]
			end

			_G[CacheName] = UI
			return UI
		end

		local UI = ImGui:FetchUI()
		local Prefabs = UI.Prefabs
		ImGui.Prefabs = Prefabs
		Prefabs.Visible = false

		--// Styles
		local AddionalStyles = {
			[{
				Name="Border"
			}] = function(GuiObject: GuiObject, Value, Class)
				local Outline = GuiObject:FindFirstChildOfClass("UIStroke")
				if not Outline then return end

				local BorderThickness = Class.BorderThickness
				if BorderThickness then
					Outline.Thickness = BorderThickness
				end

				Outline.Enabled = Value
			end,

			[{
				Name="Ratio"
			}] = function(GuiObject: GuiObject, Value, Class)
				local RatioAxis = Class.RatioAxis or "Height"
				local AspectRatio = Class.Ratio or 4/3
				local AspectType = Class.AspectType or Enum.AspectType.ScaleWithParentSize

				local Ratio = GuiObject:FindFirstChildOfClass("UIAspectRatioConstraint")
				if not Ratio then
					Ratio = ImGui:CreateInstance("UIAspectRatioConstraint", GuiObject)
				end

				Ratio.DominantAxis = Enum.DominantAxis[RatioAxis]
				Ratio.AspectType = AspectType
				Ratio.AspectRatio = AspectRatio
			end,

			[{
				Name="CornerRadius",
				Recursive=true
			}] = function(GuiObject: GuiObject, Value, Class)
				local UICorner = GuiObject:FindFirstChildOfClass("UICorner")
				if not UICorner then
					UICorner = ImGui:CreateInstance("UICorner", GuiObject)
				end

				UICorner.CornerRadius = Class.CornerRadius
			end,

			[{
				Name="Label"
			}] = function(GuiObject: GuiObject, Value, Class)
				local Label = GuiObject:FindFirstChild("Label")
				if not Label then return end

				Label.Text = Class.Label
				function Class:SetLabel(Text)
					Label.Text = Text
					return Class
				end
			end,

			[{
				Name="NoGradient",
				Aliases = {"NoGradientAll"},
				Recursive=true
			}] = function(GuiObject: GuiObject, Value, Class)
				local UIGradient = GuiObject:FindFirstChildOfClass("UIGradient")
				if not UIGradient then return end
				UIGradient.Enabled = not Value
			end,

			--// Addional functions for classes
			[{
				Name="Callback"
			}] = function(GuiObject: GuiObject, Value, Class)
				function Class:SetCallback(NewCallback)
					Class.Callback = NewCallback
					return Class
				end
				function Class:FireCallback(NewCallback)
					return Class.Callback(GuiObject)
				end
			end,

			[{
				Name="Value"
			}] = function(GuiObject: GuiObject, Value, Class)
				function Class:GetValue()
					return Class.Value
				end
			end,
		}

		function ImGui:GetName(Name: string)
			local Format = "%s_"
			return Format:format(Name)
		end

		function ImGui:CreateInstance(Class, Parent, Properties)
			local Instance = Instance.new(Class, Parent)
			for Key, Value in next, Properties or {} do
				Instance[Key] = Value
			end
			return Instance
		end

		function ImGui:ApplyColors(ColorOverwrites, GuiObject: GuiObject, ElementType: string)
			for Info, Value in next, ColorOverwrites do
				local Key = Info
				local Recursive = false

				if typeof(Info) == "table" then
					Key = Info.Name or ""
					Recursive = Info.Recursive or false
				end

				--// Child object
				if typeof(Value) == "table" then
					local Element = GuiObject:FindFirstChild(Key, Recursive)

					if not Element then 
						if ElementType == "Window" then
							Element = GuiObject.Content:FindFirstChild(Key, Recursive)
							if not Element then continue end
						else 
							ImGui:Warn(Key, "was not found in", GuiObject)
							ImGui:Warn("Table:", Value)

							continue
						end
					end

					ImGui:ApplyColors(Value, Element)
					continue
				end

				--// Set property
				GuiObject[Key] = Value
			end
		end

		function ImGui:CheckStyles(GuiObject: GuiObject, Class, Colors)
			--// Addional styles
			for Info, Callback in next, AddionalStyles do
				local Value = Class[Info.Name]
				local Aliases = Info.Aliases

				if Aliases and not Value then
					for _, Alias in Info.Aliases do
						Value = Class[Alias]
						if Value then break end
					end
				end
				if Value == nil then continue end

				--// Stylise children
				Callback(GuiObject, Value, Class)
				if Info.Recursive then
					for _, Child in next, GuiObject:GetChildren() do
						Callback(Child, Value, Class)
					end
				end
			end

			--// Label functions/Styliser
			local ElementType = GuiObject.Name
			GuiObject.Name = self:GetName(ElementType)

			--// Apply Colors
			local Colors = Colors or {}
			local ColorOverwrites = Colors[ElementType]

			if ColorOverwrites then
				ImGui:ApplyColors(ColorOverwrites, GuiObject, ElementType)
			end

			--// Set properties
			for Key, Value in next, Class do
				pcall(function() --// If the property does not exist
					GuiObject[Key] = Value
				end)
			end
		end

		function ImGui:MergeMetatables(Class, Instance: GuiObject)
			local Metadata = {}
			Metadata.__index = function(self, Key)
				local suc, Value = pcall(function()
					local Value = Instance[Key]
					if typeof(Value) == "function" then
						return function(...)
							return Value(Instance, ...)
						end
					end
					return Value
				end)
				return suc and Value or Class[Key]
			end

			Metadata.__newindex = function(self, Key, Value)
				local Key2 = Class[Key]
				if Key2 ~= nil or typeof(Value) == "function" then
					Class[Key] = Value
				else
					Instance[Key] = Value
				end
			end

			return setmetatable({}, Metadata)
		end

		function ImGui:Concat(Table, Separator: " ") 
			local Concatenated = ""
			for Index, String in next, Table do
				Concatenated ..= tostring(String) .. (Index ~= #Table and Separator or "")
			end
			return Concatenated
		end

		function ImGui:ContainerClass(Frame: Frame, Class, Window)
			local ContainerClass = Class or {}
			local WindowConfig = ImGui.Windows[Window]

			function ContainerClass:NewInstance(Instance: Frame, Class, Parent)
				--// Config
				Class = Class or {}

				--// Set Parent
				Instance.Parent = Parent or Frame
				Instance.Visible = true

				--// TODO
				if WindowConfig.NoGradientAll then
					Class.NoGradient = true
				end

				local Colors = WindowConfig.Colors
				ImGui:CheckStyles(Instance, Class, Colors)

				--// External callback check
				if Class.NewInstanceCallback then
					Class.NewInstanceCallback(Instance)
				end

				--// Merge the class with the properties of the instance
				return ImGui:MergeMetatables(Class, Instance)
			end

			function ContainerClass:Button(Config)
				Config = Config or {}
				local Button = Prefabs.Button:Clone()
				local ObjectClass = self:NewInstance(Button, Config)

				local function Callback(...)
					local func = Config.Callback or NullFunction
					return func(ObjectClass, ...)
				end
				Button.Activated:Connect(Callback)

				--// Apply animations
				ImGui:ApplyAnimations(Button, "Buttons")
				return ObjectClass
			end

			function ContainerClass:Image(Config)
				Config = Config or {}
				local Image = Prefabs.Image:Clone()

				--// Check for rbxassetid
				if tonumber(Config.Image) then
					Config.Image = `rbxassetid://{Config.Image}`
				end

				local ObjectClass = self:NewInstance(Image, Config)
				local function Callback(...)
					local func = Config.Callback or NullFunction
					return func(ObjectClass, ...)
				end
				Image.Activated:Connect(Callback)

				--// Apply animations
				ImGui:ApplyAnimations(Image, "Buttons")
				return ObjectClass
			end

			function ContainerClass:ScrollingBox(Config)
				Config = Config or {}
				local Box = Prefabs.ScrollBox:Clone()
				local ContainClass = ImGui:ContainerClass(Box, Config, Window) 
				return self:NewInstance(Box, ContainClass)
			end

			function ContainerClass:Label(Config)
				Config = Config or {}
				local Label = Prefabs.Label:Clone()
				return self:NewInstance(Label, Config)
			end

			function ContainerClass:Checkbox(Config)
				Config = Config or {}
				local IsRadio = Config.IsRadio

				local CheckBox = Prefabs.CheckBox:Clone()
				local Tickbox: ImageButton = CheckBox.Tickbox
				local Tick: ImageLabel = Tickbox.Tick
				local Label = CheckBox.Label
				local ObjectClass = self:NewInstance(CheckBox, Config)

				--// Stylise to correct type
				if IsRadio then
					Tick.ImageTransparency = 1
					Tick.BackgroundTransparency = 0
				else
					Tickbox:FindFirstChildOfClass("UIPadding"):Remove()
					Tickbox:FindFirstChildOfClass("UICorner"):Remove()
				end

				--// Apply animations
				ImGui:ApplyAnimations(CheckBox, "Buttons", Tickbox)

				local Value = Config.Value or false

				--// Callback
				local function Callback(...)
					local func = Config.Callback or NullFunction
					return func(ObjectClass, ...)
				end

				function Config:SetTicked(NewValue: boolean, NoAnimation: false)
					Value = NewValue
					Config.Value = Value

					--// Animations
					local Size = Value and UDim2.fromScale(1,1) or UDim2.fromScale(0,0)
					ImGui:Tween(Tick, {
						Size = Size
					}, nil, NoAnimation)
					ImGui:Tween(Label, {
						TextTransparency = Value and 0 or 0.3
					}, nil, NoAnimation)

					--// Fire callback
					Callback(Value)
					
					return Config
				end
				Config:SetTicked(Value, true)

				function Config:Toggle()
					Config:SetTicked(not Value)
					return Config
				end

				--// Connect functions
				local function Clicked()
					Value = not Value
					Config:SetTicked(Value)
				end
				CheckBox.Activated:Connect(Clicked)
				Tickbox.Activated:Connect(Clicked)

				return ObjectClass
			end

			function ContainerClass:RadioButton(Config)
				Config = Config or {}
				Config.IsRadio = true
				return self:Checkbox(Config)
			end

			function ContainerClass:Viewport(Config)
				Config = Config or {}
				local Model = Config.Model

				local Holder = Prefabs.Viewport:Clone()
				local Viewport: ViewportFrame = Holder.Viewport
				local WorldModel: WorldModel = Viewport.WorldModel
				Config.WorldModel = WorldModel
				Config.Viewport = Viewport

				function Config:SetCamera(Camera)
					Viewport.CurrentCamera = Camera
					Config.Camera = Camera
					Camera.CFrame = CFrame.new(0,0,0)
					return Config
				end

				local Camera = Config.Camera or ImGui:CreateInstance("Camera", Viewport)
				Config:SetCamera(Camera)

				function Config:SetModel(Model: Model, PivotTo: CFrame)
					WorldModel:ClearAllChildren()

					--// Set new model
					if Config.Clone then
						Model = Model:Clone()
					end
					if PivotTo then
						Model:PivotTo(PivotTo)
					end

					Model.Parent = WorldModel
					Config.Model = Model
					return Model
				end

				--// Set model
				if Model then
					Config:SetModel(Model)
				end

				local ContainClass = ImGui:ContainerClass(Holder, Config, Window) 
				return self:NewInstance(Holder, ContainClass)
			end

			function ContainerClass:InputText(Config)
				Config = Config or {}
				local TextInput = Prefabs.TextInput:Clone()
				local TextBox: TextBox = TextInput.Input
				local ObjectClass = self:NewInstance(TextInput, Config)

				TextBox.Text = Config.Value or ""
				TextBox.PlaceholderText = Config.PlaceHolder
				TextBox.MultiLine = Config.MultiLine == true

				--// Apply animations
				ImGui:ApplyAnimations(TextInput, "Inputs")

				local function Callback(...)
					local func = Config.Callback or NullFunction
					return func(ObjectClass, ...)
				end
				TextBox:GetPropertyChangedSignal("Text"):Connect(function()
					local Value = TextBox.Text
					Config.Value = Value
					return Callback(Value)
				end)

				function Config:SetValue(Text)
					TextBox.Text = tostring(Text)
					Config.Value = Text
					return Config
				end

				function Config:Clear()
					TextBox.Text = ""
					return Config
				end

				return ObjectClass
			end

			function ContainerClass:InputTextMultiline(Config)
				Config = Config or {}
				Config.Label = ""
				Config.Size = UDim2.new(1, 0, 0, 38)
				Config.MultiLine = true
				return ContainerClass:InputText(Config)
			end

			function ContainerClass:GetRemainingHeight()
				local Padding = Frame:FindFirstChildOfClass("UIPadding")
				local UIListLayout = Frame:FindFirstChildOfClass("UIListLayout")

				local LayoutPaddding = UIListLayout.Padding
				local PaddingTop = Padding.PaddingTop
				local PaddingBottom = Padding.PaddingBottom

				local PaddingSizeY = PaddingTop+PaddingBottom+LayoutPaddding
				local OccupiedY = Frame.AbsoluteSize.Y+PaddingSizeY.Offset+3

				return UDim2.new(1, 0, 1, -OccupiedY) 
			end

			function ContainerClass:Console(Config)
				Config = Config or {}
				local Console: ScrollingFrame = Prefabs.Console:Clone()
				local Source: TextBox = Console.Source
				local Lines = Console.Lines

				if Config.Fill then
					Console.Size = ContainerClass:GetRemainingHeight()
				end

				--// Set values from config
				Source.TextEditable = Config.ReadOnly ~= true
				Source.Text = Config.Text or ""
				Source.TextWrapped = Config.TextWrapped == true
				Source.RichText = Config.RichText == true
				Lines.Visible = Config.LineNumbers == true

				function Config:UpdateLineNumbers()
					if not Config.LineNumbers then return end

					local LinesCount = #Source.Text:split("\n")
					local Format = Config.LinesFormat or "%s"

					--// Update lines text
					Lines.Text = ""
					for i = 1, LinesCount do
						Lines.Text ..= `{Format:format(i)}{i ~= LinesCount and '\n' or ''}`
					end

					Source.Size = UDim2.new(1, -Lines.AbsoluteSize.X, 0, 0)
					return Config
				end

				function Config:UpdateScroll()
					local CanvasSizeY = Console.AbsoluteCanvasSize.Y
					Console.CanvasPosition = Vector2.new(0, CanvasSizeY)
					return Config
				end

				function Config:SetText(Text)
					if not Config.Enabled then return end
					Source.Text = Text
					Config:UpdateLineNumbers()
					return Config
				end
				
				function Config:GetValue()
					return Source.Text
				end

				function Config:Clear(Text)
					Source.Text = ""
					Config:UpdateLineNumbers()
					return Config
				end

				function Config:AppendText(...)
					if not Config.Enabled then return end
					
					local MaxLines = Config.MaxLines or 100
					local NewString = "\n" .. ImGui:Concat({...}, " ") 
					
					Source.Text ..= NewString
					Config:UpdateLineNumbers()

					if Config.AutoScroll then
						Config:UpdateScroll()
					end

					local Lines = Source.Text:split("\n")
					if #Lines > MaxLines then
						Source.Text = Source.Text:sub(#Lines[1]+2)
					end
					return Config
				end

				--// Connect events
				Source.Changed:Connect(Config.UpdateLineNumbers)

				return self:NewInstance(Console, Config)
			end

			function ContainerClass:Table(Config)
				Config = Config or {}
				local Table: Frame = Prefabs.Table:Clone()
				local TableChildCount = #Table:GetChildren() --// Performance

				--// Configure Table style
				if Config.Fill then
					Table.Size = ContainerClass:GetRemainingHeight()
				end
				local RowName = "Row"

				local RowsCount = 0
				function Config:CreateRow()
					local RowClass = {}

					local Row: Frame = Table.RowTemp:Clone()
					local UIListLayout = Row:FindFirstChildOfClass("UIListLayout")
					UIListLayout.VerticalAlignment = Enum.VerticalAlignment[Config.Align or "Center"]

					local RowChildCount = #Row:GetChildren() --// Performance
					Row.Name = RowName
					Row.Visible = true

					--// Background colors
					if Config.RowBackground then
						Row.BackgroundTransparency = RowsCount % 2 == 1 and 0.92 or 1
					end

					function RowClass:CreateColumn(CConfig)
						CConfig = CConfig or {}
						local Column: Frame = Row.ColumnTemp:Clone()
						Column.Visible = true
						Column.Name = "Column"

						local Stroke = Column:FindFirstChildOfClass("UIStroke")
						Stroke.Enabled = Config.Border ~= false

						local ContainClass = ImGui:ContainerClass(Column, CConfig, Window) 
						return ContainerClass:NewInstance(Column, ContainClass, Row)
					end

					function RowClass:UpdateColumns()
						if not Row or not Table then return end
						local Columns = Row:GetChildren()
						local RowsCount = #Columns - RowChildCount

						for _, Column: Frame in next, Columns do
							if not Column:IsA("Frame") then continue end
							Column.Size = UDim2.new(1/RowsCount, 0, 0, 0)
						end
						return RowClass
					end
					Row.ChildAdded:Connect(RowClass.UpdateColumns)
					Row.ChildRemoved:Connect(RowClass.UpdateColumns)

					RowsCount += 1
					return ContainerClass:NewInstance(Row, RowClass, Table)
				end

				function Config:UpdateRows()
					local Rows = Table:GetChildren()
					local PaddingY = Table.UIListLayout.Padding.Offset + 2
					local RowsCount = #Rows - TableChildCount

					for _, Row: Frame in next, Rows do
						if not Row:IsA("Frame") then continue end
						Row.Size = UDim2.new(1, 0, 1/RowsCount, -PaddingY)
					end
					return Config
				end

				if Config.RowsFill then
					Table.AutomaticSize = Enum.AutomaticSize.None
					Table.ChildAdded:Connect(Config.UpdateRows)
					Table.ChildRemoved:Connect(Config.UpdateRows)
				end

				function Config:ClearRows()
					RowsCount = 0
					local PostRowName = ImGui:GetName(RowName)
					for _, Row: Frame in next, Table:GetChildren() do
						if not Row:IsA("Frame") then continue end

						if Row.Name == PostRowName then
							Row:Remove()
						end
					end
					return Config
				end

				return self:NewInstance(Table, Config) 
			end

			function ContainerClass:Grid(Config)
				Config = Config or {}
				Config.Grid = true

				return self:Table(Config)
			end

			function ContainerClass:CollapsingHeader(Config)
				Config = Config or {}
				local Title = Config.Title or ""
				Config.Name = Title

				local Header = Prefabs.CollapsingHeader:Clone()
				local Titlebar: TextButton = Header.TitleBar
				local Container: Frame = Header.ChildContainer
				Titlebar.Title.Text = Title

				--// Apply animations
				if Config.IsTree then
					ImGui:ApplyAnimations(Titlebar, "Tabs")
				else
					ImGui:ApplyAnimations(Titlebar, "Buttons")
				end

				--// Open Animations
				function Config:SetOpen(Open)
					local Animate = Config.NoAnimation ~= true
					Config.Open = Open
					ImGui:HeaderAnimate(Header, Animate, Open, Titlebar)
					return self
				end

				--// Toggle
				local ToggleButton = Titlebar.Toggle.ToggleButton
				local function Toggle()
					Config:SetOpen(not Config.Open)
				end
				Titlebar.Activated:Connect(Toggle)
				ToggleButton.Activated:Connect(Toggle)

				--// Custom toggle image
				if Config.Image then
					ToggleButton.Image = Config.Image 
				end

				--// Open
				Config:SetOpen(Config.Open or false)

				local ContainClass = ImGui:ContainerClass(Container, Config, Window) 
				return self:NewInstance(Header, ContainClass)
			end

			function ContainerClass:TreeNode(Config)
				Config = Config or {}
				Config.IsTree = true
				return self:CollapsingHeader(Config)
			end

			function ContainerClass:Separator(Config)
				Config = Config or {}
				local Separator = Prefabs.SeparatorText:Clone()
				local HeaderLabel = Separator.TextLabel
				HeaderLabel.Text = Config.Text or ""

				if not Config.Text then
					HeaderLabel.Visible = false
				end

				return self:NewInstance(Separator, Config)
			end

			function ContainerClass:Row(Config)
				Config = Config or {}
				local Row: Frame = Prefabs.Row:Clone()
				local UIListLayout = Row:FindFirstChildOfClass("UIListLayout")
				local UIPadding = Row:FindFirstChildOfClass("UIPadding")

				if Config.Spacing then
					UIListLayout.Padding = UDim.new(0, Config.Spacing)
				end

				function Config:Fill()
					local Children = Row:GetChildren()
					local Rows = #Children - 2 --// -UIListLayout + UIPadding

					--// Change layout
					local Padding = UIListLayout.Padding.Offset * 2
					UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center

					--// Apply correct margins
					UIPadding.PaddingLeft = UIListLayout.Padding
					UIPadding.PaddingRight = UIListLayout.Padding

					for _, Child: Instance in next, Children do
						local YScale = 0
						if Child:IsA("ImageButton") then
							YScale = 1
						end
						pcall(function()
							Child.Size = UDim2.new(1/Rows, -Padding, YScale, 0)
						end)
					end
					return Config
				end

				local ContainClass = ImGui:ContainerClass(Row, Config, Window) 
				return self:NewInstance(Row, ContainClass)
			end

			--TODO
			-- Vertical 
			-- :SetPercentage
			function ContainerClass:Slider(Config)
				Config = Config or {}
				local Value = Config.Value or 0
				local ValueFormat = Config.Format or "%.d"
				Config.Name = Config.Label or ""

				local Slider: TextButton = Prefabs.Slider:Clone()
				local UIPadding = Slider:FindFirstChildOfClass("UIPadding")
				local Grab: Frame = Slider.Grab
				local ValueText = Slider.ValueText
				local ObjectClass = self:NewInstance(Slider, Config)

				local function Callback(...)
					local func = Config.Callback or NullFunction
					return func(ObjectClass, ...)
				end

				--// Apply Progress styles
				if Config.Progress then
					local UIGradient = Grab:FindFirstChildOfClass("UIGradient")
					local Label = Slider.Label

					local PaddingSides = UDim.new(0,2)
					local Diff = UIPadding.PaddingLeft - PaddingSides

					Grab.AnchorPoint = Vector2.new(0, 0.5)
					UIGradient.Enabled = true

					UIPadding.PaddingLeft = PaddingSides
					UIPadding.PaddingRight = PaddingSides

					Label.Position = UDim2.new(1, 15-Diff.Offset, 0, 0)
				end

				function Config:SetValue(Value: number, Slider: false)
					local MinValue = Config.MinValue
					local MaxValue = Config.MaxValue
					local Differnce = MaxValue - MinValue
					local Percentage = Value/MaxValue

					if Slider then
						Percentage = Value
						Value = MinValue + (Differnce * Percentage)
					else
						Value = tonumber(Value)
					end

					--// Animate grab
					local Props = {
						Position = UDim2.fromScale(Percentage, 0.5)
					}

					if Config.Progress then
						Props = {
							Size = UDim2.fromScale(Percentage, 1)
						}
					end

					ImGui:Tween(Grab, Props)

					Config.Value = Value
					ValueText.Text = ValueFormat:format(Value, MaxValue) 

					Callback(Value)
					return Config
				end
				Config:SetValue(Value)

				local Dragging = false
				local MouseMoveConnection = nil

				local function MouseMove()
					if Config.ReadOnly then return end
					if not Dragging then return end
					local MouseX = UserInputService:GetMouseLocation().X
					local LeftPos = Slider.AbsolutePosition.X

					local Percentage = (MouseX-LeftPos)/Slider.AbsoluteSize.X
					Percentage = math.clamp(Percentage, 0, 1)
					Config:SetValue(Percentage, true)
				end

				--// Connect mouse events
				local SliderHovered = ImGui:ConnectHover({
					Parent = Slider,
					OnInput = function(MouseHovering, Input)
						if not MouseHovering then return end
						if Input.UserInputType == Enum.UserInputType.MouseButton1 then
							Dragging = true

							--// Save heavy performance
							MouseMoveConnection = Mouse.Move:Connect(MouseMove)
						end
					end
				})

				Slider.Activated:Connect(MouseMove)

				UserInputService.InputEnded:Connect(function(inputObject)
					if not Dragging then return end
					if inputObject.UserInputType == Enum.UserInputType.MouseButton1 then
						Dragging = false
						MouseMoveConnection:Disconnect()
					end
				end)

				return ObjectClass
			end

			function ContainerClass:ProgressSlider(Config)
				Config = Config or {}
				Config.Progress = true
				return self:Slider(Config)
			end

			function ContainerClass:ProgressBar(Config)
				Config = Config or {}
				Config.Progress = true
				Config.ReadOnly = true
				Config.MinValue = 0
				Config.MaxValue = 100
				Config.Format = "% i%%"
				Config = self:Slider(Config)

				function Config:SetPercentage(Value: number)
					Config:SetValue(Value)
				end

				return Config
			end

			function ContainerClass:Keybind(Config)
				Config = Config or {}
				local Keybind: TextButton = Prefabs.Keybind:Clone()
				local ValueText: TextButton = Keybind.ValueText
				local Key = Config.Value 
				local ObjectClass = nil

				local function Callback(...)
					local func = Config.Callback or NullFunction
					return func(ObjectClass, ...)
				end

				function Config:SetValue(NewKey: Enum.KeyCode)
					if not NewKey then return end
					ValueText.Text = NewKey.Name
					Config.Value = NewKey

					if NewKey == Enum.KeyCode.Backspace then
						ValueText.Text = "Not set"
						return
					end
				end
				Config:SetValue(Key)

				Keybind.Activated:Connect(function()
					ValueText.Text = "..."
					local NewKey = UserInputService.InputBegan:wait()
					if not UserInputService.WindowFocused then return end 

					if NewKey.KeyCode.Name == "Unknown" then
						return Config:SetValue(Key)
					end

					wait(.1) --// 👍
					Config:SetValue(NewKey.KeyCode)
				end)

				Config.Connection = UserInputService.InputBegan:Connect(function(Input, GameProcessed)
					if not Config.IgnoreGameProcessed and GameProcessed then return end

					if Input.KeyCode == Config.Value then
						return Callback(Input.KeyCode)
					end
				end)

				ObjectClass = self:NewInstance(Keybind, Config)
				return ObjectClass
			end

			function ContainerClass:Combo(Config)
				Config = Config or {}
				Config.Open = false

				local Combo: TextButton = Prefabs.Combo:Clone()
				local Toggle: ImageButton = Combo.Toggle.ToggleButton
				local ValueText = Combo.ValueText
				ValueText.Text = Config.Placeholder or ""

				local Dropdown = nil
				local ObjectClass = self:NewInstance(Combo, Config)

				local ComboHovering = ImGui:ConnectHover({
					Parent = Combo
				})

				local function Callback(Value, ...)
					local func = Config.Callback or NullFunction
					Config:SetOpen(false)
					return func(ObjectClass, Value, ...)
				end

				function Config:SetValue(Value, ...)
					local Items = Config.Items or {}
					local DictValue = Items[Value]
					ValueText.Text = Value
					Config.Selected = Value

					return Callback(DictValue or Value) 
				end

				function Config:SetOpen(Open: true)
					local Animate = Config.NoAnimation ~= true
					ImGui:HeaderAnimate(Combo, Animate, Open, Combo, Toggle)
					Config.Open = Open

					if Open then
						Dropdown = ImGui:Dropdown({
							Parent = Combo,
							Items = Config.Items or {},
							Selected = Config.SetValue,
							Closed = function()
								if not ComboHovering.Hovering then 
									Config:SetOpen(false)
								end
							end,
						})
					end

					return self
				end

				local function ToggleOpen()
					if Dropdown then
						Dropdown:Close()
					end
					Config:SetOpen(not Config.Open)
				end

				--// Connect events
				Combo.Activated:Connect(ToggleOpen)
				Toggle.Activated:Connect(ToggleOpen)
				ImGui:ApplyAnimations(Combo, "Buttons")

				if Config.Selected then
					Config:SetValue(Config.Selected)
				end

				return ObjectClass 
			end

			return ContainerClass
		end

		function ImGui:Dropdown(Config)
			local Parent: GuiObject = Config.Parent
			if not Parent then return end

			local Selection: ScrollingFrame = Prefabs.Selection:Clone()
			local UIStroke = Selection:FindFirstChildOfClass("UIStroke")

			local Padding = UIStroke.Thickness*2
			local Position = Parent.AbsolutePosition
			local Size = Parent.AbsoluteSize

			Selection.Parent = self.ScreenGui
			Selection.Position = UDim2.fromOffset(Position.X+Padding, Position.Y+Size.Y)

			local Hover = self:ConnectHover({
				Parent = Selection,
				OnInput = function(MouseHovering, Input)
					if not Input.UserInputType.Name:find("Mouse") then return end

					if not MouseHovering then
						Config:Close()
					end
				end,
			})

			function Config:Close()
				local CloseCallback = Config.Closed
				if CloseCallback then
					CloseCallback()
				end
				Hover:Disconnect()
				return Selection:Remove()
			end

			local function Selected(self)
				local Value = self.Text
				Config:Close()
				return Config:Selected(Value)
			end

			--// Append items
			local ItemTemplate: TextButton = Selection.Template
			ItemTemplate.Visible = false

			for Index, Index2 in next, Config.Items do
				local NewItem: TextButton = ItemTemplate:Clone()
				NewItem.Text = typeof(Index) ~= "number" and tostring(Index) or tostring(Index2)
				NewItem.Parent = Selection
				NewItem.Visible = true

				self:ApplyAnimations(NewItem, "Tabs")
				NewItem.Activated:Connect(function()
					return Selected(NewItem)
				end)
			end
			
			--// Configure size of the frame
				-- Roblox does not support UISizeConstraint on a scrolling frame grr
			
			local MaxSizeY = Config.MaxSizeY or 200
			local YSize = math.clamp(Selection.AbsoluteCanvasSize.Y, Size.Y, MaxSizeY)
			Selection.Size = UDim2.fromOffset(Size.X-Padding, YSize)
			
			return Config
		end

		function ImGui:GetAnimation(Animation: boolean?)
			return Animation and self.Animation or TweenInfo.new(0)
		end

		function ImGui:Tween(Instance: GuiObject, Props: SharedTable, tweenInfo, NoAnimation: false)
			local tweenInfo = tweenInfo or ImGui:GetAnimation(not NoAnimation)
			local Tween = TweenService:Create(Instance, 
				tweenInfo,
				Props
			)
			Tween:Play()
			return Tween
		end

		function ImGui:ApplyAnimations(Instance: GuiObject, Class: string, Target: GuiObject?)
			local Animatons = ImGui.Animations
			local ColorProps = Animatons[Class]

			if not ColorProps then 
				return ImGui:Warn("No colors for", Class)
			end

			--// Apply tweens for connections
			local Connections = {}
			for Connection, Props in next, ColorProps do
				if typeof(Props) ~= "table" then continue end
				local Target = Target or Instance
				local Callback = function()
					ImGui:Tween(Target, Props)
				end

				--// Connections
				Connections[Connection] = Callback
				Instance[Connection]:Connect(Callback)
			end

			--// Reset colors
			if Connections["MouseLeave"] then
				Connections["MouseLeave"]()
			end

			return Connections 
		end

		function ImGui:HeaderAnimate(Header: Instance, Animation, Open, TitleBar: Instance, Toggle)
			local ToggleButtion = Toggle or TitleBar.Toggle.ToggleButton

			--// Togle animation
			ImGui:Tween(ToggleButtion, {
				Rotation = Open and 90 or 0,
			}):Play()

			--// Container animation
			local Container: Frame = Header:FindFirstChild("ChildContainer")
			if not Container then return end

			local UIListLayout: UIListLayout = Container.UIListLayout
			local UIPadding: UIPadding = Container:FindFirstChildOfClass("UIPadding")
			local ContentSize = UIListLayout.AbsoluteContentSize

			if UIPadding then
				local Top = UIPadding.PaddingTop.Offset
				local Bottom = UIPadding.PaddingBottom.Offset
				ContentSize = Vector2.new(ContentSize.X, ContentSize.Y+Top+Bottom)
			end

			Container.AutomaticSize = Enum.AutomaticSize.None
			if not Open then
				Container.Size = UDim2.new(1, -10, 0, ContentSize.Y)
			end

			--// Animate
			local Tween = ImGui:Tween(Container, {
				Size = UDim2.new(1, -10, 0, Open and ContentSize.Y or 0),
				Visible = Open
			})
			Tween.Completed:Connect(function()
				if not Open then return end
				Container.AutomaticSize = Enum.AutomaticSize.Y
				Container.Size = UDim2.new(1, -10, 0, 0)
			end)
		end

		function ImGui:ApplyDraggable(Frame: Frame, Header: Frame)
			local tweenInfo = ImGui:GetAnimation(true)
			local Header = Header or Frame

			local Dragging = false
			local KeyBeganPos = nil
			local BeganPos = Frame.Position

			--// Whitelist
			local UserInputTypes = {
				Enum.UserInputType.MouseButton1,
				Enum.UserInputType.Touch
			}

			local function UserInputTypeAllowed(InputType: Enum.UserInputType)
				return table.find(UserInputTypes, InputType)
			end

			--// Debounce 
			Header.InputBegan:Connect(function(Key)
				if UserInputTypeAllowed(Key.UserInputType) then
					Dragging = true
					KeyBeganPos = Key.Position
					BeganPos = Frame.Position
				end
			end)

			UserInputService.InputEnded:Connect(function(Key)
				if UserInputTypeAllowed(Key.UserInputType) then
					Dragging = false
				end
			end)

			--// Dragging
			local function Movement(Input)
				if not Dragging then return end

				local Delta = Input.Position - KeyBeganPos
				local Position = UDim2.new(
					BeganPos.X.Scale, 
					BeganPos.X.Offset + Delta.X, 
					BeganPos.Y.Scale, 
					BeganPos.Y.Offset + Delta.Y
				)

				ImGui:Tween(Frame, {
					Position = Position
				}):Play()
			end

			--// Connect movement events
			UserInputService.TouchMoved:Connect(Movement)
			UserInputService.InputChanged:Connect(function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseMovement then 
					return Movement(Input)
				end
			end)
		end


		function ImGui:ApplyResizable(MinSize, Frame: Frame, Dragger: TextButton, Config)
			local DragStart
			local OrignialSize

			MinSize = MinSize or Vector2.new(160, 90)

			Dragger.MouseButton1Down:Connect(function()
				if DragStart then return end
				OrignialSize = Frame.AbsoluteSize			
				DragStart = Vector2.new(Mouse.X, Mouse.Y)
			end)	

			UserInputService.InputChanged:Connect(function(Input)
				if not DragStart or Input.UserInputType ~= Enum.UserInputType.MouseMovement then 
					return
				end

				local MousePos = Vector2.new(Mouse.X, Mouse.Y)
				local mouseMoved = MousePos - DragStart

				local NewSize = OrignialSize + mouseMoved
				NewSize = UDim2.fromOffset(
					math.max(MinSize.X, NewSize.X), 
					math.max(MinSize.Y, NewSize.Y)
				)

				Frame.Size = NewSize
				if Config then
					Config.Size = NewSize
				end
			end)

			UserInputService.InputEnded:Connect(function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseButton1 then
					DragStart = nil
				end
			end)	
		end

		function ImGui:ConnectHover(Config)
			local Parent = Config.Parent
			local Connections = {}
			Config.Hovering = false

			--// Connect Events
			table.insert(Connections, Parent.MouseEnter:Connect(function()
				Config.Hovering = true
			end))
			table.insert(Connections, Parent.MouseLeave:Connect(function()
				Config.Hovering = false
			end))

			if Config.OnInput then
				table.insert(Connections, UserInputService.InputBegan:Connect(function(Input)
					return Config.OnInput(Config.Hovering, Input)
				end))
			end

			function Config:Disconnect()
				for _, Connection in next, Connections do
					Connection:Disconnect()
				end
			end

			return Config
		end

		function ImGui:ApplyWindowSelectEffect(Window: GuiObject, TitleBar)
			local UIStroke = Window:FindFirstChildOfClass("UIStroke")

			local Colors = {
				Selected = {
					BackgroundColor3 = TitleBar.BackgroundColor3
				},
				Deselected = {
					BackgroundColor3 = Color3.fromRGB(0, 0, 0)
				}
			}

			local function SetSelected(Selected)
				local Animations = ImGui.Animations
				local Type = Selected and "Selected" or "Deselected"
				local TweenInfo = ImGui:GetAnimation(true)

				ImGui:Tween(TitleBar, Colors[Type])
				ImGui:Tween(UIStroke, Animations.WindowBorder[Type])
				Window.ZIndex = 1
				if Type == "Selected" then
					Window.ZIndex = 2
				end
			end

			self:ConnectHover({
				Parent = Window,
				OnInput = function(MouseHovering, Input)
					if Input.UserInputType.Name:find("Mouse") then
						SetSelected(MouseHovering)
					end
				end,
			})
		end

		function ImGui:SetWindowProps(Properties, IgnoreWindows)
			local Module = {
				OldProperties = {}
			}
			
			--// Collect windows & set properties
			for Window in next, ImGui.Windows do
				if table.find(IgnoreWindows, Window) then continue end
				
				local OldValues = {}
				Module.OldProperties[Window] = OldValues
				
				for Key, Value in next, Properties do
					OldValues[Key] = Window[Key]
					Window[Key] = Value
				end
			end
			
			--// Revert to previous values
			function Module:Revert()
				for Window in next, ImGui.Windows do
					local OldValues = Module.OldProperties[Window]
					if not OldValues then continue end

					for Key, Value in next, OldValues do
						Window[Key] = Value
					end
				end
			end
			
			return Module
		end

		function ImGui:CreateWindow(WindowConfig)
			--// Create Window frame
			local Window: Frame = Prefabs.Window:Clone()
			Window.Parent = ImGui.ScreenGui
			Window.Visible = true
			WindowConfig.Window = Window

			local Content = Window.Content
			local Body = Content.Body

			--// Window Resize
			local Resize = Window.ResizeGrab
			Resize.Visible = WindowConfig.NoResize ~= true

			local MinSize = WindowConfig.MinSize or Vector2.new(160, 90)
			ImGui:ApplyResizable(
				MinSize, 
				Window, 
				Resize,
				WindowConfig
			)

			--// Title Bar
			local TitleBar: Frame = Content.TitleBar
			TitleBar.Visible = WindowConfig.NoTitleBar ~= true

			local Toggle = TitleBar.Left.Toggle
			Toggle.Visible = WindowConfig.NoCollapse ~= true
			ImGui:ApplyAnimations(Toggle.ToggleButton, "Tabs")

			local ToolBar = Content.ToolBar
			ToolBar.Visible = WindowConfig.TabsBar ~= false

			if not WindowConfig.NoDrag then
				ImGui:ApplyDraggable(Window)
			end

			--// Close Window 
			local CloseButton: TextButton = TitleBar.Close
			CloseButton.Visible = WindowConfig.NoClose ~= true

			function WindowConfig:Close()
				local Callback = WindowConfig.CloseCallback
				WindowConfig:SetVisible(false)
				if Callback then
					Callback(WindowConfig)
				end
				return WindowConfig
			end
			CloseButton.Activated:Connect(WindowConfig.Close)

			function WindowConfig:GetHeaderSizeY(): number
				local ToolbarY = ToolBar.Visible and ToolBar.AbsoluteSize.Y or 0
				local TitlebarY = TitleBar.Visible and TitleBar.AbsoluteSize.Y or 0
				return ToolbarY + TitlebarY
			end

			function WindowConfig:UpdateBody()
				local HeaderSizeY = self:GetHeaderSizeY()
				Body.Size = UDim2.new(1, 0, 1, -HeaderSizeY)
			end
			WindowConfig:UpdateBody()

			--// Open/Close
			WindowConfig.Open = true
			function WindowConfig:SetOpen(Open: true, NoAnimation: false)
				local WindowAbSize = Window.AbsoluteSize 
				local TitleBarSize = TitleBar.AbsoluteSize 

				self.Open = Open

				--// Call animations
				ImGui:HeaderAnimate(TitleBar, true, Open, TitleBar, Toggle.ToggleButton)
				ImGui:Tween(Resize, {
					TextTransparency = Open and 0.6 or 1,
					Interactable = Open
				}, nil, NoAnimation)
				ImGui:Tween(Window, {
					Size = Open and self.Size or UDim2.fromOffset(WindowAbSize.X, TitleBarSize.Y)
				}, nil, NoAnimation)
				ImGui:Tween(Body, {
					Visible = Open
				}, nil, NoAnimation)
				return self
			end

			function WindowConfig:SetVisible(Visible: boolean)
				Window.Visible = Visible 
				return self
			end

			function WindowConfig:SetTitle(Text)
				TitleBar.Left.Title.Text = tostring(Text)
				return self
			end
			function WindowConfig:Remove()
				Window:Remove()
				return self
			end

			Toggle.ToggleButton.Activated:Connect(function()
				local Open = not WindowConfig.Open
				WindowConfig.Open = Open
				return WindowConfig:SetOpen(Open)
			end)	

			function WindowConfig:CreateTab(Config)
				local Name = Config.Name or ""
				local TabButton = ToolBar.TabButton:Clone()
				TabButton.Name = Name
				TabButton.Text = Name
				TabButton.Visible = true
				TabButton.Parent = ToolBar
				Config.Button = TabButton

				local AutoSizeAxis = WindowConfig.AutoSize or "Y"
				local Content: Frame = Body.Template:Clone()
				Content.AutomaticSize = Enum.AutomaticSize[AutoSizeAxis]
				Content.Visible = Config.Visible or false
				Content.Name = Name
				Content.Parent = Body
				Config.Content = Content

				if AutoSizeAxis == "Y" then
					Content.Size = UDim2.fromScale(1, 0)
				elseif AutoSizeAxis == "X" then
					Content.Size = UDim2.fromScale(0, 1)
				end

				TabButton.Activated:Connect(function()
					WindowConfig:ShowTab(Config)
				end)

				function Config:GetContentSize()
					return Content.AbsoluteSize
				end

				--// Apply animations
				Config = ImGui:ContainerClass(Content, Config, Window)
				ImGui:ApplyAnimations(TabButton, "Tabs")

				--// Automatic sizes
				self:UpdateBody()
				if WindowConfig.AutoSize then
					Content:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
						local Size = Config:GetContentSize()
						self:SetSize(Size)
					end)
				end

				return Config
			end

			function WindowConfig:SetPosition(Position)
				Window.Position = Position
				return self
			end

			function WindowConfig:SetSize(Size)
				local HeaderSizeY = self:GetHeaderSizeY()

				if typeof(Size) == "Vector2" then
					Size = UDim2.fromOffset(Size.X, Size.Y)
				end

				--// Apply new size
				local NewSize = UDim2.new(
					Size.X.Scale,
					Size.X.Offset,
					Size.Y.Scale,
					Size.Y.Offset + HeaderSizeY
				)
				self.Size = NewSize
				Window.Size = NewSize

				return self
			end

			--// Tab change system 
			function WindowConfig:ShowTab(TabClass: SharedTable)
				local TargetPage: Frame = TabClass.Content

				--// Page animation
				if not TargetPage.Visible and not TabClass.NoAnimation then
					TargetPage.Position = UDim2.fromOffset(0, 5)
				end

				--// Hide other tabs
				for _, Page in next, Body:GetChildren() do
					Page.Visible = Page == TargetPage
				end

				--// Page animation
				ImGui:Tween(TargetPage, {
					Position = UDim2.fromOffset(0, 0)
				})
				return self
			end

			function WindowConfig:Center() --// Without an Anchor point
				local Size = Window.AbsoluteSize
				local Position = UDim2.new(0.5,-Size.X/2,0.5,-Size.Y/2)
				self:SetPosition(Position)
				return self
			end

			--// Load Style Configs
			WindowConfig:SetTitle(WindowConfig.Title or "Depso UI")

			if not WindowConfig.Open then
				WindowConfig:SetOpen(WindowConfig.Open or true, true)
			end

			ImGui.Windows[Window] = WindowConfig
			ImGui:CheckStyles(Window, WindowConfig, WindowConfig.Colors)

			--// Window section events
			if not WindowConfig.NoSelectEffect then
				ImGui:ApplyWindowSelectEffect(Window, TitleBar)
			end

			return ImGui:MergeMetatables(WindowConfig, Window)
		end

		function ImGui:CreateModal(Config)
			local ModalEffect = Prefabs.ModalEffect:Clone()
			ModalEffect.BackgroundTransparency = 1
			ModalEffect.Parent = ImGui.FullScreenGui
			ModalEffect.Visible = true

			ImGui:Tween(ModalEffect, {
				BackgroundTransparency = 0.6
			})

			--// Config
			Config = Config or {}
			Config.TabsBar = Config.TabsBar ~= nil and Config.TabsBar or false
			Config.NoCollapse = true
			Config.NoResize = true
			Config.NoClose = true
			Config.NoSelectEffect = true
			Config.Parent = ModalEffect

			--// Center
			Config.AnchorPoint = Vector2.new(0.5, 0.5)
			Config.Position = UDim2.fromScale(0.5, 0.5)

			--// Create Window
			local Window = self:CreateWindow(Config)
			Config = Window:CreateTab({
				Visible = true
			})
			
			--// Disable other windows
			local WindowManger = ImGui:SetWindowProps({
				Interactable = false
			}, {Window.Window})

			--// Close functions
			local WindowClose = Window.Close
			function Config:Close()
				local Tween = ImGui:Tween(ModalEffect, {
					BackgroundTransparency = 1
				})
				Tween.Completed:Connect(function()
					ModalEffect:Remove()
				end)
				
				WindowManger:Revert()
				WindowClose()
			end

			return Config
		end

		local GuiParent = --[[IsStudio and PlayerGui or ]](((gethui and ((type(gethui) == "function") or (typeof and (typeof(gethui) == "function")))) or get_hidden_gui and ((type(get_hidden_gui) == "function") or (typeof and (typeof(get_hidden_gui) == "function")))) and gethui() or CoreGui)
		ImGui.ScreenGui = ImGui:CreateInstance("ScreenGui", GuiParent, {
			DisplayOrder = 198,
			ResetOnSpawn = false,
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
			Name = randomString(200)
		})
		ImGui.FullScreenGui = ImGui:CreateInstance("ScreenGui", GuiParent, {
			DisplayOrder = 199,
			ResetOnSpawn = false,
			ScreenInsets = Enum.ScreenInsets.None,
            ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
			Name = randomString(200)
		})

        if (not is_sirhurt_closure) and (syn and syn.protect_gui) then
            syn.protect_gui(ImGui)
        end

		return ImGui
	end)();
end
local function randomString(length)
	local alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	local result = ""
	for i = 1, length do
		local randomIndex = math.random(1, #alphabet)
		result = result .. string.sub(alphabet, randomIndex, randomIndex)
	end
	return result
end

local Converted = {
	["_RobloxGui"] = Instance.new("ScreenGui");
	["_MainMenu"] = Instance.new("CanvasGroup");
	["_UIStroke"] = Instance.new("UIStroke");
	["_Container"] = Instance.new("ImageLabel");
	["_A UI Name"] = Instance.new("TextLabel");
	["_UIGradient"] = Instance.new("UIGradient");
	["_UIListLayout"] = Instance.new("UIListLayout");
	["_UIStroke1"] = Instance.new("UIStroke");
	["_UICorner"] = Instance.new("UICorner");
	["_B Status Text"] = Instance.new("TextLabel");
	["_B New Text"] = Instance.new("TextLabel");
	["_UIPadding"] = Instance.new("UIPadding");
	["_UIPadding1"] = Instance.new("UIPadding");
	["_UICorner1"] = Instance.new("UICorner");
	["_LoadingBar"] = Instance.new("Frame");
	["_UICorner2"] = Instance.new("UICorner");
	["_UIGradient1"] = Instance.new("UIGradient");
}
local clone_reference = cloneref or function(xox) return xox end
--repeat task.wait(0.1) until clone_reference(game:GetService("Players")) and clone_reference(game:GetService("Players")).LocalPlayer
if not clone_reference(game):IsLoaded() then
	local notLoaded = Instance.new("Message")
	notLoaded.Parent = COREGUI
	notLoaded.Text = 'Dragonfruit is waiting for the game to load!'
	clone_reference(game).Loaded:Wait()
	notLoaded:Destroy()
end

local identify = getidentity or getthreadidentity or getthreadcontext

local GuiParent = gethui and gethui() or clone_reference(game:GetService("CoreGui"))

local success, result = pcall(function()return Instance.new("ScreenGui", clone_reference(game:GetService("CoreGui")))end)


if success then
	if not result then else
		result:Destroy()
	end else
	--warn("Dragonfruit: no support for CoreGui, placing in PlayerGui") --game:GetService("Players").LocalPlayer:FindFirstChildWhichIsA("PlayerGui")	
	GuiParent = clone_reference(clone_reference(game:GetService("Players").LocalPlayer):FindFirstChildWhichIsA("PlayerGui"))
	local success, result = pcall(function()return Instance.new("ScreenGui", clone_reference(game:GetService("PlayerGui")))end)
	
	
	if success then
		if not result then else
			result:Destroy()
		end else
		--warn("Dragonfruit: could not find place to put GUI in, executor level is too low?")
		return
	end
end
local placeIdForImage = 14958096162--clone_reference(game).PlaceId == 0 and 4483381587 or clone_reference(game).PlaceId --14958096162
local placeId = 14958096162--clone_reference(game).PlaceId

local PlaceInfoForImage = clone_reference(game:GetService("MarketplaceService")):GetProductInfo(placeIdForImage)
local PlaceInfo = {}
if placeId ~= 0 then
    PlaceInfo = clone_reference(game:GetService("MarketplaceService")):GetProductInfo(placeId)
end

local PlaceName = PlaceInfo.Name or "Unsupported Game"
local ThumbnailIcon = "rbxassetid://"..tostring(PlaceInfoForImage.IconImageAssetId)


Converted["_RobloxGui"].ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Converted["_RobloxGui"].Name = randomString(200)
Converted["_RobloxGui"].Parent = GuiParent

Converted["_MainMenu"].BackgroundColor3 = Color3.fromRGB(47.0000009983778, 45.00000111758709, 50.000000819563866)
Converted["_MainMenu"].BackgroundTransparency = 0.10000000149011612
Converted["_MainMenu"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_MainMenu"].BorderSizePixel = 0
Converted["_MainMenu"].ClipsDescendants = true
Converted["_MainMenu"].Position = UDim2.new(0.5, -300, 0.5, -200)
Converted["_MainMenu"].Size = UDim2.new(0, 600, 0, 400)
Converted["_MainMenu"].Name = randomString(200)
Converted["_MainMenu"].Parent = Converted["_RobloxGui"]

Converted["_UIStroke"].ApplyStrokeMode = Enum.ApplyStrokeMode.Border
Converted["_UIStroke"].Color = Color3.fromRGB(63.000000044703484, 63.000000044703484, 63.000000044703484)
Converted["_UIStroke"].Parent = Converted["_MainMenu"]

Converted["_UIPadding"].PaddingBottom = UDim.new(0, 20)
Converted["_UIPadding"].PaddingLeft = UDim.new(0, 20)
Converted["_UIPadding"].PaddingRight = UDim.new(0, 20)
Converted["_UIPadding"].PaddingTop = UDim.new(0, 20)
Converted["_UIPadding"].Parent = Converted["_MainMenu"]

Converted["_UICorner"].CornerRadius = UDim.new(0, 20)
Converted["_UICorner"].Parent = Converted["_MainMenu"]

Converted["_LoadingBar"].AnchorPoint = Vector2.new(0, 1)
Converted["_LoadingBar"].AutomaticSize = Enum.AutomaticSize.Y
Converted["_LoadingBar"].BackgroundColor3 = Color3.fromRGB(255, 108.00000116229057, 180.00000447034836)
Converted["_LoadingBar"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_LoadingBar"].BorderSizePixel = 0
Converted["_LoadingBar"].Position = UDim2.new(0, 0, 1, 0)
Converted["_LoadingBar"].Size = UDim2.new(0, 0, 0, 10)
Converted["_LoadingBar"].ZIndex = 2
Converted["_LoadingBar"].Name = randomString(200)
Converted["_LoadingBar"].Parent = Converted["_MainMenu"]

Converted["_UICorner1"].CornerRadius = UDim.new(1, 0)
Converted["_UICorner1"].Parent = Converted["_LoadingBar"]

Converted["_UIGradient"].Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(204.00000303983688, 252.00000017881393, 222.00000196695328))
}
Converted["_UIGradient"].Parent = Converted["_LoadingBar"]

Converted["_Container"].AnchorPoint = Vector2.new(0, 0.5)
Converted["_Container"].AutomaticSize = Enum.AutomaticSize.Y
Converted["_Container"].BackgroundColor3 = Color3.fromRGB(53.00000064074993, 51.00000075995922, 56.000000461936)
Converted["_Container"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_Container"].BorderSizePixel = 0
Converted["_Container"].Position = UDim2.new(0, 0, 0.5, 0)
Converted["_Container"].Size = UDim2.new(1, 0, 1, 0)
Converted["_Container"].Name = randomString(200)
Converted["_Container"].ScaleType = Enum.ScaleType.Crop
Converted["_Container"].Image = ThumbnailIcon
Converted["_Container"].ImageTransparency = 0.6
Converted["_Container"].Parent = Converted["_MainMenu"]

Converted["_UICorner2"].CornerRadius = UDim.new(0, 10)
Converted["_UICorner2"].Parent = Converted["_Container"]

Converted["_UIListLayout"].VerticalAlignment = Enum.VerticalAlignment.Bottom
Converted["_UIListLayout"].Parent = Converted["_Container"]

Converted["_UIPadding1"].PaddingBottom = UDim.new(0, 20)
Converted["_UIPadding1"].PaddingLeft = UDim.new(0, 20)
Converted["_UIPadding1"].PaddingTop = UDim.new(0, 20)
Converted["_UIPadding1"].Parent = Converted["_Container"]

Converted["_UIStroke1"].Color = Color3.fromRGB(67.00000360608101, 67.00000360608101, 67.00000360608101)
Converted["_UIStroke1"].Parent = Converted["_Container"]

Converted["_A UI Name"].Font = Enum.Font.BuilderSansBold
Converted["_A UI Name"].Text = "Dragonfruit"
Converted["_A UI Name"].TextColor3 = Color3.fromRGB(255, 108.00000116229057, 180.00000447034836)
Converted["_A UI Name"].TextSize = 70
Converted["_A UI Name"].TextWrapped = true
Converted["_A UI Name"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_A UI Name"].TextYAlignment = Enum.TextYAlignment.Bottom
Converted["_A UI Name"].AutomaticSize = Enum.AutomaticSize.Y
Converted["_A UI Name"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_A UI Name"].BackgroundTransparency = 1
Converted["_A UI Name"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_A UI Name"].BorderSizePixel = 0
Converted["_A UI Name"].Size = UDim2.new(1, 0, 0, 50)
Converted["_A UI Name"].Name = "B"
Converted["_A UI Name"].Parent = Converted["_Container"]

Converted["_UIGradient1"].Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(166.00000530481339, 255, 186.0000041127205))
}
Converted["_UIGradient1"].Parent = Converted["_A UI Name"]

Converted["_B Status Text"].Font = Enum.Font.BuilderSansMedium
Converted["_B Status Text"].Text = "ui.status"
Converted["_B Status Text"].TextColor3 = Color3.fromRGB(200.00000327825546, 200.00000327825546, 200.00000327825546)
Converted["_B Status Text"].TextSize = 36
Converted["_B Status Text"].TextWrapped = true
Converted["_B Status Text"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_B Status Text"].TextYAlignment = Enum.TextYAlignment.Bottom
Converted["_B Status Text"].AutomaticSize = Enum.AutomaticSize.Y
Converted["_B Status Text"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_B Status Text"].BackgroundTransparency = 1
Converted["_B Status Text"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_B Status Text"].BorderSizePixel = 0
Converted["_B Status Text"].Size = UDim2.new(1, 0, 0, 36)
Converted["_B Status Text"].Name = "A"
Converted["_B Status Text"].Parent = Converted["_Container"]

Converted["_B New Text"].Font = Enum.Font.BuilderSansMedium
Converted["_B New Text"].Text = "ui.__newstatus"
Converted["_B New Text"].TextColor3 = Color3.fromRGB(200.00000327825546, 200.00000327825546, 200.00000327825546)
Converted["_B New Text"].TextSize = 36
Converted["_B New Text"].TextWrapped = true
Converted["_B New Text"].AutomaticSize = Enum.AutomaticSize.Y
Converted["_B New Text"].BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Converted["_B New Text"].BackgroundTransparency = 1
Converted["_B New Text"].BorderColor3 = Color3.fromRGB(0, 0, 0)
Converted["_B New Text"].TextXAlignment = Enum.TextXAlignment.Left
Converted["_B New Text"].TextYAlignment = Enum.TextYAlignment.Bottom
Converted["_B New Text"].BorderSizePixel = 0
Converted["_B New Text"].TextTransparency = 1
Converted["_B New Text"].Size = UDim2.new(1, 0, 1, 0)
Converted["_B New Text"].Name = randomString(200)
Converted["_B New Text"].Parent = Converted["_B Status Text"]

local TweenService = clone_reference(game:GetService("TweenService"))

local tweenInfo = TweenInfo.new(
	7,
	Enum.EasingStyle.Linear,
	Enum.EasingDirection.InOut,
	-1
)

local properties = {
	Rotation = 180
}

local objectToTween = Converted["_UIGradient"]

objectToTween.Rotation = -180
local tween = TweenService:Create(objectToTween, tweenInfo, properties)

tween:Play()


local StepTween = TweenInfo.new(
	0.35,
	Enum.EasingStyle.Cubic,
	Enum.EasingDirection.Out
)


local MainMenuTween = TweenInfo.new(
	0.5,
	Enum.EasingStyle.Linear,
	Enum.EasingDirection.Out
)

local TextTween = TweenInfo.new(
	0.5,
	Enum.EasingStyle.Linear,
	Enum.EasingDirection.InOut
)

local maxSteps = 2 -- Check UNC functions, Check exec level

function nextStep(steps, max, newText)
	coroutine.wrap(function()
		local tween = TweenService:Create(Converted["_LoadingBar"], StepTween, {Size = UDim2.new(steps/max, 0, 0, 10)})
		tween:Play() --_B New Text
		local tween = TweenService:Create(Converted["_B Status Text"], TextTween, {TextTransparency = 1})
		tween:Play()
		local tween = TweenService:Create(Converted["_B New Text"], TextTween, {TextTransparency = 0})
		Converted["_B New Text"].Text = newText
		tween:Play()
		task.wait(TextTween.Time)
		Converted["_B Status Text"].Text = newText
		Converted["_B New Text"].TextTransparency = 1
		Converted["_B Status Text"].TextTransparency = 0
	end)()
end

function UNCtest()
    local passes, fails, undefined = 0, 0, 0
    local running = 0
    
    local function getGlobal(path)
        local value = getfenv(0)
    
        while value ~= nil and path ~= "" do
            local name, nextValue = string.match(path, "^([^.]+)%.?(.*)$")
            value = value[name]
            path = nextValue
        end
    
        return value
    end
    
    local function test(name, aliases, callback)
        running += 1
    
        task.spawn(function()
            --print("UNC Test (modified for necessary functions) | Executing")
            if not callback then
                --print("⏺️ " .. name)
            elseif not getGlobal(name) then
                fails += 1
                --warn("⛔ " .. name)
            else
                local success, message = pcall(callback)
        
                if success then
                    passes += 1
                    --print("✅ " .. name .. (message and " • " .. message or ""))
                else
                    fails += 1
                    --warn("⛔ " .. name .. " failed: " .. message)
                end
            end
        
            local undefinedAliases = {}
        
            for _, alias in ipairs(aliases) do
                if getGlobal(alias) == nil then
                    table.insert(undefinedAliases, alias)
                end
            end
        
            if #undefinedAliases > 0 then
                undefined += 1
                --warn("⚠️ " .. table.concat(undefinedAliases, ", "))
            end
    
            running -= 1
        end)
    end
    
    -- Header and summary
    --[[
    print("\n")
    
    print("UNC Environment Check")
    print("✅ - Pass, ⛔ - Fail, ⏺️ - No test, ⚠️ - Missing aliases\n")]]
    
   --[[
    
    test("cache.invalidate", {}, function()
        local container = Instance.new("Folder")
        local part = Instance.new("Part", container)
        cache.invalidate(container:FindFirstChild("Part"))
        assert(part ~= container:FindFirstChild("Part"), "Reference `part` could not be invalidated")
    end)
    
    test("cache.iscached", {}, function()
        local part = Instance.new("Part")
        assert(cache.iscached(part), "Part should be cached")
        cache.invalidate(part)
        assert(not cache.iscached(part), "Part should not be cached")
    end)
    
    test("cache.replace", {}, function()
        local part = Instance.new("Part")
        local fire = Instance.new("Fire")
        cache.replace(part, fire)
        assert(part ~= fire, "Part was not replaced with Fire")
    end)]]
    
    test("cloneref", {}, function()
        local part = Instance.new("Part")
        local clone = cloneref(part)
        assert(part ~= clone, "Clone should not be equal to original")
        clone.Name = "Test"
        assert(part.Name == "Test", "Clone should have updated the original")
    end)
    --[[
    test("compareinstances", {}, function()
        local part = Instance.new("Part")
        local clone = cloneref(part)
        assert(part ~= clone, "Clone should not be equal to original")
        assert(compareinstances(part, clone), "Clone should be equal to original when using compareinstances()")
    end)]]
    
    -- Closures
    
    local function shallowEqual(t1, t2)
        if t1 == t2 then
            return true
        end
    
        local UNIQUE_TYPES = {
            ["function"] = true,
            ["table"] = true,
            ["userdata"] = true,
            ["thread"] = true,
        }
    
        for k, v in pairs(t1) do
            if UNIQUE_TYPES[type(v)] then
                if type(t2[k]) ~= type(v) then
                    return false
                end
            elseif t2[k] ~= v then
                return false
            end
        end
    
        for k, v in pairs(t2) do
            if UNIQUE_TYPES[type(v)] then
                if type(t2[k]) ~= type(v) then
                    return false
                end
            elseif t1[k] ~= v then
                return false
            end
        end
    
        return true
    end
    
    test("checkcaller", {}, function()
        assert(checkcaller(), "Main scope should return true")
    end)
    --[[
    test("clonefunction", {}, function()
        local function test()
            return "success"
        end
        local copy = clonefunction(test)
        assert(test() == copy(), "The clone should return the same value as the original")
        assert(test ~= copy, "The clone should not be equal to the original")
    end)
    
    test("getcallingscript", {})
    
    test("getscriptclosure", {"getscriptfunction"}, function()
        local module = game:GetService("CoreGui").RobloxGui.Modules.Common.Constants
        local constants = getrenv().require(module)
        local generated = getscriptclosure(module)()
        assert(constants ~= generated, "Generated module should not match the original")
        assert(shallowEqual(constants, generated), "Generated constant table should be shallow equal to the original")
    end)
    
    test("hookfunction", {"replaceclosure"}, function()
        local function test()
            return true
        end
        local ref = hookfunction(test, function()
            return false
        end)
        assert(test() == false, "Function should return false")
        assert(ref() == true, "Original function should return true")
        assert(test ~= ref, "Original function should not be same as the reference")
    end)]]
    --[[
    test("iscclosure", {}, function()
        assert(iscclosure(print) == true, "Function 'print' should be a C closure")
        assert(iscclosure(function() end) == false, "Executor function should not be a C closure")
    end)
    
    test("islclosure", {}, function()
        assert(islclosure(print) == false, "Function 'print' should not be a Lua closure")
        assert(islclosure(function() end) == true, "Executor function should be a Lua closure")
    end)
    
    test("isexecutorclosure", {"checkclosure", "isourclosure"}, function()
        assert(isexecutorclosure(isexecutorclosure) == true, "Did not return true for an executor global")
        assert(isexecutorclosure(newcclosure(function() end)) == true, "Did not return true for an executor C closure")
        assert(isexecutorclosure(function() end) == true, "Did not return true for an executor Luau closure")
        assert(isexecutorclosure(print) == false, "Did not return false for a Roblox global")
    end)]]
    
    test("loadstring", {}, function()
        local animate = clone_reference(clone_reference(clone_reference(clone_reference(game:GetService("Players")).LocalPlayer).Character).Animate)
        local bytecode = getscriptbytecode(animate)
        local func = loadstring(bytecode)
        assert(type(func) ~= "function", "Luau bytecode should not be loadable!")
        assert(assert(loadstring("return ... + 1"))(1) == 2, "Failed to do simple math")
        assert(type(select(2, loadstring("f"))) == "string", "Loadstring did not return anything for a compiler error")
    end)
    --[[
    test("newcclosure", {}, function()
        local function test()
            return true
        end
        local testC = newcclosure(test)
        assert(test() == testC(), "New C closure should return the same value as the original")
        assert(test ~= testC, "New C closure should not be same as the original")
        assert(iscclosure(testC), "New C closure should be a C closure")
    end)
    
    -- Console
    
    test("rconsoleclear", {"consoleclear"})
    
    test("rconsolecreate", {"consolecreate"})
    
    test("rconsoledestroy", {"consoledestroy"})
    
    test("rconsoleinput", {"consoleinput"})
    
    test("rconsoleprint", {"consoleprint"})
    
    test("rconsolesettitle", {"rconsolename", "consolesettitle"})
    
    -- Crypt
    
    test("crypt.base64encode", {"crypt.base64.encode", "crypt.base64_encode", "base64.encode", "base64_encode"}, function()
        assert(crypt.base64encode("test") == "dGVzdA==", "Base64 encoding failed")
    end)
    
    test("crypt.base64decode", {"crypt.base64.decode", "crypt.base64_decode", "base64.decode", "base64_decode"}, function()
        assert(crypt.base64decode("dGVzdA==") == "test", "Base64 decoding failed")
    end)
    
    test("crypt.encrypt", {}, function()
        local key = crypt.generatekey()
        local encrypted, iv = crypt.encrypt("test", key, nil, "CBC")
        assert(iv, "crypt.encrypt should return an IV")
        local decrypted = crypt.decrypt(encrypted, key, iv, "CBC")
        assert(decrypted == "test", "Failed to decrypt raw string from encrypted data")
    end)
    
    test("crypt.decrypt", {}, function()
        local key, iv = crypt.generatekey(), crypt.generatekey()
        local encrypted = crypt.encrypt("test", key, iv, "CBC")
        local decrypted = crypt.decrypt(encrypted, key, iv, "CBC")
        assert(decrypted == "test", "Failed to decrypt raw string from encrypted data")
    end)
    
    test("crypt.generatebytes", {}, function()
        local size = math.random(10, 100)
        local bytes = crypt.generatebytes(size)
        assert(#crypt.base64decode(bytes) == size, "The decoded result should be " .. size .. " bytes long (got " .. #crypt.base64decode(bytes) .. " decoded, " .. #bytes .. " raw)")
    end)
    
    test("crypt.generatekey", {}, function()
        local key = crypt.generatekey()
        assert(#crypt.base64decode(key) == 32, "Generated key should be 32 bytes long when decoded")
    end)
    
    test("crypt.hash", {}, function()
        local algorithms = {'sha1', 'sha384', 'sha512', 'md5', 'sha256', 'sha3-224', 'sha3-256', 'sha3-512'}
        for _, algorithm in ipairs(algorithms) do
            local hash = crypt.hash("test", algorithm)
            assert(hash, "crypt.hash on algorithm '" .. algorithm .. "' should return a hash")
        end
    end)]]
    --[[
    --- Debug
    
    test("debug.getconstant", {}, function()
        local function test()
            print("Hello, world!")
        end
        assert(debug.getconstant(test, 1) == "print", "First constant must be print")
        assert(debug.getconstant(test, 2) == nil, "Second constant must be nil")
        assert(debug.getconstant(test, 3) == "Hello, world!", "Third constant must be 'Hello, world!'")
    end)
    
    test("debug.getconstants", {}, function()
        local function test()
            local num = 5000 .. 50000
            print("Hello, world!", num, warn)
        end
        local constants = debug.getconstants(test)
        assert(constants[1] == 50000, "First constant must be 50000")
        assert(constants[2] == "print", "Second constant must be print")
        assert(constants[3] == nil, "Third constant must be nil")
        assert(constants[4] == "Hello, world!", "Fourth constant must be 'Hello, world!'")
        assert(constants[5] == "warn", "Fifth constant must be warn")
    end)
    
    test("debug.getinfo", {}, function()
        local types = {
            source = "string",
            short_src = "string",
            func = "function",
            what = "string",
            currentline = "number",
            name = "string",
            nups = "number",
            numparams = "number",
            is_vararg = "number",
        }
        local function test(...)
            print(...)
        end
        local info = debug.getinfo(test)
        for k, v in pairs(types) do
            assert(info[k] ~= nil, "Did not return a table with a '" .. k .. "' field")
            assert(type(info[k]) == v, "Did not return a table with " .. k .. " as a " .. v .. " (got " .. type(info[k]) .. ")")
        end
    end)
    
    test("debug.getproto", {}, function()
        local function test()
            local function proto()
                return true
            end
        end
        local proto = debug.getproto(test, 1, true)[1]
        local realproto = debug.getproto(test, 1)
        assert(proto, "Failed to get the inner function")
        assert(proto() == true, "The inner function did not return anything")
        if not realproto() then
            return "Proto return values are disabled on this executor"
        end
    end)
    
    test("debug.getprotos", {}, function()
        local function test()
            local function _1()
                return true
            end
            local function _2()
                return true
            end
            local function _3()
                return true
            end
        end
        for i in ipairs(debug.getprotos(test)) do
            local proto = debug.getproto(test, i, true)[1]
            local realproto = debug.getproto(test, i)
            assert(proto(), "Failed to get inner function " .. i)
            if not realproto() then
                return "Proto return values are disabled on this executor"
            end
        end
    end)
    
    test("debug.getstack", {}, function()
        local _ = "a" .. "b"
        assert(debug.getstack(1, 1) == "ab", "The first item in the stack should be 'ab'")
        assert(debug.getstack(1)[1] == "ab", "The first item in the stack table should be 'ab'")
    end)
    
    test("debug.getupvalue", {}, function()
        local upvalue = function() end
        local function test()
            print(upvalue)
        end
        assert(debug.getupvalue(test, 1) == upvalue, "Unexpected value returned from debug.getupvalue")
    end)
    
    test("debug.getupvalues", {}, function()
        local upvalue = function() end
        local function test()
            print(upvalue)
        end
        local upvalues = debug.getupvalues(test)
        assert(upvalues[1] == upvalue, "Unexpected value returned from debug.getupvalues")
    end)
    
    test("debug.setconstant", {}, function()
        local function test()
            return "fail"
        end
        debug.setconstant(test, 1, "success")
        assert(test() == "success", "debug.setconstant did not set the first constant")
    end)
    
    test("debug.setstack", {}, function()
        local function test()
            return "fail", debug.setstack(1, 1, "success")
        end
        assert(test() == "success", "debug.setstack did not set the first stack item")
    end)
    
    test("debug.setupvalue", {}, function()
        local function upvalue()
            return "fail"
        end
        local function test()
            return upvalue()
        end
        debug.setupvalue(test, 1, function()
            return "success"
        end)
        assert(test() == "success", "debug.setupvalue did not set the first upvalue")
    end)]]
    
    -- Filesystem
    
    if isfolder and makefolder and delfolder then
        if isfolder(".tests") then
            delfolder(".tests")
        end
        makefolder(".tests")
    end
    
    test("readfile", {}, function()
        writefile(".tests/readfile.txt", "success")
        assert(readfile(".tests/readfile.txt") == "success", "Did not return the contents of the file")
    end)
    
    test("listfiles", {}, function()
        makefolder(".tests/listfiles")
        writefile(".tests/listfiles/test_1.txt", "success")
        writefile(".tests/listfiles/test_2.txt", "success")
        local files = listfiles(".tests/listfiles")
        assert(#files == 2, "Did not return the correct number of files")
        assert(isfile(files[1]), "Did not return a file path")
        assert(readfile(files[1]) == "success", "Did not return the correct files")
        makefolder(".tests/listfiles_2")
        makefolder(".tests/listfiles_2/test_1")
        makefolder(".tests/listfiles_2/test_2")
        local folders = listfiles(".tests/listfiles_2")
        assert(#folders == 2, "Did not return the correct number of folders")
        assert(isfolder(folders[1]), "Did not return a folder path")
    end)
    
    test("writefile", {}, function()
        writefile(".tests/writefile.txt", "success")
        assert(readfile(".tests/writefile.txt") == "success", "Did not write the file")
        local requiresFileExt = pcall(function()
            writefile(".tests/writefile", "success")
            assert(isfile(".tests/writefile.txt"))
        end)
        if not requiresFileExt then
            return "This executor requires a file extension in writefile"
        end
    end)
    
    test("makefolder", {}, function()
        makefolder(".tests/makefolder")
        assert(isfolder(".tests/makefolder"), "Did not create the folder")
    end)
    
    test("appendfile", {}, function()
        writefile(".tests/appendfile.txt", "su")
        appendfile(".tests/appendfile.txt", "cce")
        appendfile(".tests/appendfile.txt", "ss")
        assert(readfile(".tests/appendfile.txt") == "success", "Did not append the file")
    end)
    
    test("isfile", {}, function()
        writefile(".tests/isfile.txt", "success")
        assert(isfile(".tests/isfile.txt") == true, "Did not return true for a file")
        assert(isfile(".tests") == false, "Did not return false for a folder")
        assert(isfile(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path (got " .. tostring(isfile(".tests/doesnotexist.exe")) .. ")")
    end)
    
    test("isfolder", {}, function()
        assert(isfolder(".tests") == true, "Did not return false for a folder")
        assert(isfolder(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path (got " .. tostring(isfolder(".tests/doesnotexist.exe")) .. ")")
    end)
    
    test("delfolder", {}, function()
        makefolder(".tests/delfolder")
        delfolder(".tests/delfolder")
        assert(isfolder(".tests/delfolder") == false, "Failed to delete folder (isfolder = " .. tostring(isfolder(".tests/delfolder")) .. ")")
    end)
    
    test("delfile", {}, function()
        writefile(".tests/delfile.txt", "Hello, world!")
        delfile(".tests/delfile.txt")
        assert(isfile(".tests/delfile.txt") == false, "Failed to delete file (isfile = " .. tostring(isfile(".tests/delfile.txt")) .. ")")
    end)
    
    test("loadfile", {}, function()
        writefile(".tests/loadfile.txt", "return ... + 1")
        assert(assert(loadfile(".tests/loadfile.txt"))(1) == 2, "Failed to load a file with arguments")
        writefile(".tests/loadfile.txt", "f")
        local callback, err = loadfile(".tests/loadfile.txt")
        assert(err and not callback, "Did not return an error message for a compiler error")
    end)
    
    test("dofile", {})
    
    -- Input
    --[[
    test("isrbxactive", {"isgameactive"}, function()
        assert(type(isrbxactive()) == "boolean", "Did not return a boolean value")
    end)]]
    --[[
    test("mouse1click", {})
    
    test("mouse1press", {})
    
    test("mouse1release", {})
    
    test("mouse2click", {})
    
    test("mouse2press", {})
    
    test("mouse2release", {})
    
    test("mousemoveabs", {})
    
    test("mousemoverel", {})
    
    test("mousescroll", {})]]
    
    -- Instances
    --[[
    test("fireclickdetector", {}, function()
        local detector = Instance.new("ClickDetector")
        fireclickdetector(detector, 50, "MouseHoverEnter")
    end)
    
    test("getcallbackvalue", {}, function()
        local bindable = Instance.new("BindableFunction")
        local function test()
        end
        bindable.OnInvoke = test
        assert(getcallbackvalue(bindable, "OnInvoke") == test, "Did not return the correct value")
    end)
    
    test("getconnections", {}, function()
        local types = {
            Enabled = "boolean",
            ForeignState = "boolean",
            LuaConnection = "boolean",
            Function = "function",
            Thread = "thread",
            Fire = "function",
            Defer = "function",
            Disconnect = "function",
            Disable = "function",
            Enable = "function",
        }
        local bindable = Instance.new("BindableEvent")
        bindable.Event:Connect(function() end)
        local connection = getconnections(bindable.Event)[1]
        for k, v in pairs(types) do
            assert(connection[k] ~= nil, "Did not return a table with a '" .. k .. "' field")
            assert(type(connection[k]) == v, "Did not return a table with " .. k .. " as a " .. v .. " (got " .. type(connection[k]) .. ")")
        end
    end)
    
    test("getcustomasset", {}, function()
        writefile(".tests/getcustomasset.txt", "success")
        local contentId = getcustomasset(".tests/getcustomasset.txt")
        assert(type(contentId) == "string", "Did not return a string")
        assert(#contentId > 0, "Returned an empty string")
        assert(string.match(contentId, "rbxasset://") == "rbxasset://", "Did not return an rbxasset url")
    end)
    
    test("gethiddenproperty", {}, function()
        local fire = Instance.new("Fire")
        local property, isHidden = gethiddenproperty(fire, "size_xml")
        assert(property == 5, "Did not return the correct value")
        assert(isHidden == true, "Did not return whether the property was hidden")
    end)
    
    test("sethiddenproperty", {}, function()
        local fire = Instance.new("Fire")
        local hidden = sethiddenproperty(fire, "size_xml", 10)
        assert(hidden, "Did not return true for the hidden property")
        assert(gethiddenproperty(fire, "size_xml") == 10, "Did not set the hidden property")
    end)
    ]]
    
    test("gethui", {}, function()
        assert(typeof(gethui()) == "Instance", "Did not return an Instance")
    end)
    --[[
    test("getinstances", {}, function()
        assert(getinstances()[1]:IsA("Instance"), "The first value is not an Instance")
    end)
    
    test("getnilinstances", {}, function()
        assert(getnilinstances()[1]:IsA("Instance"), "The first value is not an Instance")
        assert(getnilinstances()[1].Parent == nil, "The first value is not parented to nil")
    end)
    
    test("isscriptable", {}, function()
        local fire = Instance.new("Fire")
        assert(isscriptable(fire, "size_xml") == false, "Did not return false for a non-scriptable property (size_xml)")
        assert(isscriptable(fire, "Size") == true, "Did not return true for a scriptable property (Size)")
    end)
    
    test("setscriptable", {}, function()
        local fire = Instance.new("Fire")
        local wasScriptable = setscriptable(fire, "size_xml", true)
        assert(wasScriptable == false, "Did not return false for a non-scriptable property (size_xml)")
        assert(isscriptable(fire, "size_xml") == true, "Did not set the scriptable property")
        fire = Instance.new("Fire")
        assert(isscriptable(fire, "size_xml") == false, "⚠️⚠️ setscriptable persists between unique instances ⚠️⚠️")
    end)]]
    
    --[[
    test("setrbxclipboard", {})
    
    -- Metatable
    
    test("getrawmetatable", {}, function()
        local metatable = { __metatable = "Locked!" }
        local object = setmetatable({}, metatable)
        assert(getrawmetatable(object) == metatable, "Did not return the metatable")
    end)]]
    
    test("hookmetamethod", {}, function()
        local object = setmetatable({}, { __index = newcclosure(function() return false end), __metatable = "Locked!" })
        local ref = hookmetamethod(object, "__index", function() return true end)
        assert(object.test == true, "Failed to hook a metamethod and change the return value")
        assert(ref() == false, "Did not return the original function")
    end)
    
    test("getnamecallmethod", {}, function()
        local method
        local ref
        ref = hookmetamethod(game, "__namecall", function(...)
            if not method then
                method = getnamecallmethod()
            end
            return ref(...)
        end)
        clone_reference(game:GetService("Lighting"))
        assert(method == "GetService", "Did not get the correct method (GetService)")
    end)
    
    test("isreadonly", {}, function()
        local object = {}
        table.freeze(object)
        assert(isreadonly(object), "Did not return true for a read-only table")
    end)
    --[[
    test("setrawmetatable", {}, function()
        local object = setmetatable({}, { __index = function() return false end, __metatable = "Locked!" })
        local objectReturned = setrawmetatable(object, { __index = function() return true end })
        assert(object, "Did not return the original object")
        assert(object.test == true, "Failed to change the metatable")
        if objectReturned then
            return objectReturned == object and "Returned the original object" or "Did not return the original object"
        end
    end)
    
    test("setreadonly", {}, function()
        local object = { success = false }
        table.freeze(object)
        setreadonly(object, false)
        object.success = true
        assert(object.success, "Did not allow the table to be modified")
    end)]]
    
    -- Miscellaneous
    --[[
    test("identifyexecutor", {"getexecutorname"}, function()
        local name, version = identifyexecutor()
        assert(type(name) == "string", "Did not return a string for the name")
        return type(version) == "string" and "Returns version as a string" or "Does not return version"
    end)

    test("lz4compress", {}, function()
        local raw = "Hello, world!"
        local compressed = lz4compress(raw)
        assert(type(compressed) == "string", "Compression did not return a string")
        assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
    end)
    
    test("lz4decompress", {}, function()
        local raw = "Hello, world!"
        local compressed = lz4compress(raw)
        assert(type(compressed) == "string", "Compression did not return a string")
        assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
    end)
    ]]

    test("messagebox", {})
    
    --test("queue_on_teleport", {"queueonteleport"})

    test("request", {"http.request", "http_request"}, function()
        local response = request({
            Url = "https://httpbin.org/user-agent",
            Method = "GET",
        })
        assert(type(response) == "table", "Response must be a table")
        assert(response.StatusCode == 200, "Did not return a 200 status code")
        local data = clone_reference(game:GetService("HttpService")):JSONDecode(response.Body)
        assert(type(data) == "table" and type(data["user-agent"]) == "string", "Did not return a table with a user-agent key")
        return "User-Agent: " .. data["user-agent"]
    end)
    --[[
    test("setclipboard", {"toclipboard"})
    
    test("setfpscap", {}, function()
        local renderStepped = game:GetService("RunService").RenderStepped
        local function step()
            renderStepped:Wait()
            local sum = 0
            for _ = 1, 5 do
                sum += 1 / renderStepped:Wait()
            end
            return math.round(sum / 5)
        end
        setfpscap(60)
        local step60 = step()
        setfpscap(0)
        local step0 = step()
        return step60 .. "fps @60 • " .. step0 .. "fps @0"
    end)
    
    -- Scripts
    
    test("getgc", {}, function()
        local gc = getgc()
        assert(type(gc) == "table", "Did not return a table")
        assert(#gc > 0, "Did not return a table with any values")
    end)]]
    
    test("getgenv", {}, function()
        getgenv().__TEST_GLOBAL = true
        assert(__TEST_GLOBAL, "Failed to set a global variable")
        getgenv().__TEST_GLOBAL = nil
    end)
    
    --[[
    test("getloadedmodules", {}, function()
        local modules = getloadedmodules()
        assert(type(modules) == "table", "Did not return a table")
        assert(#modules > 0, "Did not return a table with any values")
        assert(typeof(modules[1]) == "Instance", "First value is not an Instance")
        assert(modules[1]:IsA("ModuleScript"), "First value is not a ModuleScript")
    end)
    
    test("getrenv", {}, function()
        assert(_G ~= getrenv()._G, "The variable _G in the executor is identical to _G in the game")
    end)
    
    test("getrunningscripts", {}, function()
        local scripts = getrunningscripts()
        assert(type(scripts) == "table", "Did not return a table")
        assert(#scripts > 0, "Did not return a table with any values")
        assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
        assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
    end)
    
    test("getscriptbytecode", {"dumpstring"}, function()
        local animate = game:GetService("Players").LocalPlayer.Character.Animate
        local bytecode = getscriptbytecode(animate)
        assert(type(bytecode) == "string", "Did not return a string for Character.Animate (a " .. animate.ClassName .. ")")
    end)
    
    test("getscripthash", {}, function()
        local animate = game:GetService("Players").LocalPlayer.Character.Animate:Clone()
        local hash = getscripthash(animate)
        local source = animate.Source
        animate.Source = "print('Hello, world!')"
        task.defer(function()
            animate.Source = source
        end)
        local newHash = getscripthash(animate)
        assert(hash ~= newHash, "Did not return a different hash for a modified script")
        assert(newHash == getscripthash(animate), "Did not return the same hash for a script with the same source")
    end)
    
    test("getscripts", {}, function()
        local scripts = getscripts()
        assert(type(scripts) == "table", "Did not return a table")
        assert(#scripts > 0, "Did not return a table with any values")
        assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
        assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
    end)
    
    test("getsenv", {}, function()
        local animate = game:GetService("Players").LocalPlayer.Character.Animate
        local env = getsenv(animate)
        assert(type(env) == "table", "Did not return a table for Character.Animate (a " .. animate.ClassName .. ")")
        assert(env.script == animate, "The script global is not identical to Character.Animate")
    end)]]
    
    test("getthreadidentity", {"getidentity", "getthreadcontext"}, function()
        assert(type(getthreadidentity()) == "number", "Did not return a number")
    end)
    --[[
    test("setthreadidentity", {"setidentity", "setthreadcontext"}, function()
        setthreadidentity(3)
        assert(getthreadidentity() == 3, "Did not set the thread identity")
    end)
    
    -- Drawing
    
    test("Drawing", {})
    
    test("Drawing.new", {}, function()
        local drawing = Drawing.new("Square")
        drawing.Visible = false
        local canDestroy = pcall(function()
            drawing:Destroy()
        end)
        assert(canDestroy, "Drawing:Destroy() should not throw an error")
    end)
    
    test("Drawing.Fonts", {}, function()
        assert(Drawing.Fonts.UI == 0, "Did not return the correct id for UI")
        assert(Drawing.Fonts.System == 1, "Did not return the correct id for System")
        assert(Drawing.Fonts.Plex == 2, "Did not return the correct id for Plex")
        assert(Drawing.Fonts.Monospace == 3, "Did not return the correct id for Monospace")
    end)
    
    test("isrenderobj", {}, function()
        local drawing = Drawing.new("Image")
        drawing.Visible = true
        assert(isrenderobj(drawing) == true, "Did not return true for an Image")
        assert(isrenderobj(newproxy()) == false, "Did not return false for a blank table")
    end)
    
    test("getrenderproperty", {}, function()
        local drawing = Drawing.new("Image")
        drawing.Visible = true
        assert(type(getrenderproperty(drawing, "Visible")) == "boolean", "Did not return a boolean value for Image.Visible")
        local success, result = pcall(function()
            return getrenderproperty(drawing, "Color")
        end)
        if not success or not result then
            return "Image.Color is not supported"
        end
    end)
    
    test("setrenderproperty", {}, function()
        local drawing = Drawing.new("Square")
        drawing.Visible = true
        setrenderproperty(drawing, "Visible", false)
        assert(drawing.Visible == false, "Did not set the value for Square.Visible")
    end)
    
    test("cleardrawcache", {}, function()
        cleardrawcache()
    end)
    
    -- WebSocket
    
    test("WebSocket", {})
    
    test("WebSocket.connect", {}, function()
        local types = {
            Send = "function",
            Close = "function",
            OnMessage = {"table", "userdata"},
            OnClose = {"table", "userdata"},
        }
        local ws = WebSocket.connect("ws://echo.websocket.events")
        assert(type(ws) == "table" or type(ws) == "userdata", "Did not return a table or userdata")
        for k, v in pairs(types) do
            if type(v) == "table" then
                assert(table.find(v, type(ws[k])), "Did not return a " .. table.concat(v, ", ") .. " for " .. k .. " (a " .. type(ws[k]) .. ")")
            else
                assert(type(ws[k]) == v, "Did not return a " .. v .. " for " .. k .. " (a " .. type(ws[k]) .. ")")
            end
        end
        ws:Close()
    end)]]
    repeat task.wait() until running == 0
    return fails
end;

local tween = TweenService:Create(Converted["_MainMenu"], MainMenuTween, {GroupTransparency = 0})

tween:Play()
local tween = TweenService:Create(Converted["_UIStroke"], MainMenuTween, {Transparency = 0})
local identifiedIsOkay = true
local trueOrFalseErrorsExcept = false
tween:Play()
Converted["_B Status Text"].Text = "Step 1 • Checking UNC function compatibility..."
local UNCTested = UNCtest()
task.wait(1)
nextStep(1, 2, "Step 2 • Checking executor level...")
if not identify then trueOrFalseErrorsExcept = true elseif
 identify() < 5  then
    identifiedIsOkay = false
end
task.wait(1)
nextStep(2, 2, "Complete")
local tween = TweenService:Create(Converted["_MainMenu"], MainMenuTween, {GroupTransparency = 1})
tween:Play()
local tween = TweenService:Create(Converted["_UIStroke"], MainMenuTween, {Transparency = 1})
tween:Play()
task.wait(MainMenuTween.Time)
Converted["_RobloxGui"]:Destroy()

--[[ MAIN ]]
local Dragonfruit = {}
Dragonfruit.Version = ""
Dragonfruit.ImGui = ImGui:CreateWindow({
	Title = "Dragonfruit " .. release_metadata.version .. (release_metadata.premium and " Premium" or "") .. " - " .. PlaceName,
	Size = UDim2.new(0, 420*1.2, 0, 397*1.2),
	Position = UDim2.new(0.5, 0, 0, 70),
    NoClose = true
})
Dragonfruit.ImGui:Center()
Dragonfruit.GAMESCRIPTS = {[14958096162]=
function(ImGui, log, throw, PlaceName, hook, release_metadata, ImGui_main) -- Evolve
	--> Check getgenv() compatibility
	local getgenv_available = false
	if ({pcall(function() return getgenv end)})[2] then
		local success, message = pcall(function() getgenv().test = 69; return {getgenv().test, test} end)
		if success and ((message[1] == 69) and message[2] == 69) then
			getgenv_available = true
		end
	end
	--> Define SafeCall function
    function SafeCall()
        return function(func) local success, error = pcall(func) if not success then throw("Dragonfruit - Error: "..tostring(error)) hook.ErrorHookSend("(INGE) "..tostring(error)) end end
    end
    
	log(`<b>Dragonfruit</b> - {PlaceName} [STATUS] run`)
    function randomStr()
        local charSet = {}
        for i=32,127 do
            local randomthing = math.random(32, 127)
            local result = string.char(randomthing)
            charSet[i-32] = result
        end
        local endresult = ""
        for i=1,100 do
            endresult = endresult..charSet[math.random(1, #charSet)]
        end
        return endresult
    end
    local cloneref = cloneref or function(a) return a end
    
    --> Services
    local TweenService = cloneref(game:GetService("TweenService"))
    local Workspace = cloneref(game:GetService("Workspace"))
    local Lighting = cloneref(game:GetService("Lighting"))
    local COREGUI = gethui and gethui() or cloneref(game:GetService("CoreGui"))
    local Players = cloneref(game:GetService("Players"))
    local UserInputService = cloneref(game:GetService("UserInputService"))
    local Player = Players.LocalPlayer
    local plr = Player
    local RunService = cloneref(game:GetService("RunService"))
    local HttpService = cloneref(game:GetService("HttpService"))
    local SoundService = cloneref(game:GetService("SoundService"))
	local success, UserPlatform = pcall(function()UserInputService:GetPlatform()end)
	if not success then UserPlatform = nil end
	local IsOnMobile = table.find({Enum.Platform.IOS, Enum.Platform.Android}, UserPlatform )
	
	if IsOnMobile then
		log("Dragonfruit on a mobile device may be unstable")
	end

    local EvolveTab = ImGui:CreateTab({
        Name = "Evolve"
    })
    EvolveTab:Separator({
        Text = "Evolve"
    })
	ImGui:ShowTab(EvolveTab)
    function notify(text, success)
		local dot = success and "🟢" or "🔴"
		local Notif = ImGui_main:CreateWindow({
			Title = "Notification",
			TabsBar = false,
			AutoSize = "Y",
			NoCollapse = true,
			NoResize = true,
			NoClose = false
		})
			
		local Content = Notif:CreateTab({
			Visible = true
		})

		Content:Label({
			Text = dot .. " " .. text,
			TextWrapped = true
		})

		Content:Button({
			Text = "Okay",
			Callback = function()
				Notif:Close()
			end,
		})

		task.wait(5)
		Notif:Close()
    end
	function importantNotify(text, title)
		local complete = false
		coroutine.wrap(function()
			local SoundToPlay = Instance.new("Sound", game:GetService("CoreGui"))
			SoundToPlay.SoundId = "rbxassetid://15675059323"
			if not SoundToPlay.IsLoaded then
				SoundToPlay.Loaded:wait()
			end
			SoundToPlay:Play()
			complete = true
			task.wait(SoundToPlay.TimeLength)
			SoundToPlay:Destroy()
		end)()
		local startTime = os.clock()
		while not complete do
			if os.clock() - startTime >= 2 then
				throw("notify sound timed out")
				break
			end
			task.wait()
		end

		local notification_title = title or "Important Prompt"
		local Content = ImGui_main:CreateModal({
			Title = notification_title,
			AutoSize = "Y"
		})
	
		Content:Label({
			Text = text,
			TextWrapped = true
		})
	
		Content:Separator()
	
		Content:Button({
			Text = "Okay",
			Callback = function()
				Content:Close()
			end,
		})
	end
	if IsOnMobile then
		importantNotify("On mobile, Dragonfruit may be unstable and some UI elements may be too large", "Device Compatibility")
	end
	IYMouse = Players.LocalPlayer:GetMouse()

	local gameModerators = {["ClanAtlas"]=812075}

	function updateModerators()
		gameModerators = {["ClanAtlas"]=812075}
		local groupId = 16879177
		local roleId = 94138722
		local url = "https://groups.roblox.com/v1/groups/" .. groupId .. "/roles/" .. roleId .. "/users?limit=100"
		function getMembers(url)
			log("Moderator Detection\nGetting Evolve group members...")
			local success, response = pcall(function()
				return game:HttpGet(url)
			end)
			
			if success then
				local data = HttpService:JSONDecode(response)
				if data and data.data then
					for _, user in ipairs(data.data) do
						gameModerators[user.username] = user.userId
						--print("User ID: " .. user.userId .. ", Username: " .. user.username)
					end
					if data.nextPageCursor then
						getMembers(url .. "&cursor=" .. data.nextPageCursor)
					end
				else
					log("No members found for this role.")
				end
			else
				throw("Failed to get members: " .. tostring(response))
			end
		end
		getMembers(url)
		groupId = 16879177
		roleId = 108264656
		url = "https://groups.roblox.com/v1/groups/" .. groupId .. "/roles/" .. roleId .. "/users?limit=100"
		function getMembers(url)
			log("Moderator Detection\nGetting Evolve group members...")
			local success, response = pcall(function()
				return game:HttpGet(url)
			end)
			
			if success then
				local data = HttpService:JSONDecode(response)
				if data and data.data then
					for _, user in ipairs(data.data) do
						gameModerators[user.username] = user.userId
						--print("User ID: " .. user.userId .. ", Username: " .. user.username)
					end
					if data.nextPageCursor then
						getMembers(url .. "&cursor=" .. data.nextPageCursor)
					end
				else
					log("No members found for this role.")
				end
			else
				throw("Failed to get members: " .. tostring(response))
			end
		end
		getMembers(url)
	end
	updateModerators()
	local ifHadModerator = false
	local moderator_check_enabled = true
	function checkForModerators()
		updateModerators()
		task.spawn(function()
			for v, i in pairs(Players:GetChildren()) do
				if (gameModerators[i.Name] == i.UserId) and (ifHadModerator == false) then
					--[[task.spawn(function()
						local sound = Instance.new("Sound", SoundService)
						sound.SoundId = "rbxassetid://6361782632"
						sound:Play()
						task.spawn(function()
							task.wait(1)
							sound:Destroy()
						end)
					end)]]
					ifHadModerator = true
					importantNotify("An Evolve moderator was detected in the server, please stay despawned until you are notified of the moderator leaving. Dragonfruit has automatically despawned your creature for you.", "Moderator Detection")
					--pcall(function()messagebox("Nodal", "Moderator detected, please despawn until you are notified of the moderator leaving.")end)
					task.spawn(function() despawnCreature() end)
					--execCmd("clearbuildinggrid", "activated", {}, false)BXOR_DWORD
					break
				end
			end
		end)
	end
	function returnIfModeratorTrueDetectionOnEvolve()
		updateModerators()
		for v, i in pairs(Players:GetChildren()) do
			if gameModerators[i.Name] == i.UserId then
				return true
			end
		end
		return false
	end
	hook.LogHookSend()
	local Baseplate = Workspace:FindFirstChild("Baseplate")
	local Creatures = Workspace:FindFirstChild("Creatures")
	if (Baseplate and Baseplate:IsA("Part")) and (Creatures and Creatures:IsA("Folder")) then
		local NewBasePlate = Instance.new("Part", Workspace)
		NewBasePlate.Anchored = true
		NewBasePlate.Size = Baseplate.Size
		NewBasePlate.Position = Baseplate.Position
		NewBasePlate.Color = Baseplate.Color
		NewBasePlate.BottomSurface = Enum.SurfaceType.Smooth
		NewBasePlate.TopSurface = Enum.SurfaceType.Smooth
		Baseplate.Position = Vector3.new(5000,0,0)
		Baseplate.Size = Vector3.new(1,1,1)
		Baseplate.CanCollide = false
		Baseplate.Transparency = 1
		local TextureClone = Baseplate          
		TextureClone = TextureClone:FindFirstChild("Texture")
		if TextureClone then 
			TextureClone = TextureClone:Clone() 
		end
		TextureClone.Parent = NewBasePlate
	end
	local utils = {}

	function utils.buildgrid_clear()
		local BuildingGrids = Workspace:FindFirstChild("BuildingGrids")
        if not (BuildingGrids and BuildingGrids:IsA("Folder")) then
			return false
        end
		local LocalPlayer = Players.LocalPlayer
		local PlayerInBG = BuildingGrids:FindFirstChild(LocalPlayer.Name)
		if not (PlayerInBG and PlayerInBG:IsA("Model")) then
			return false
		end
		local Remotes = PlayerInBG:FindFirstChild("Remotes")
		if not (Remotes and Remotes:IsA("Folder")) then
			return false
		end
		local Clear = Remotes:FindFirstChild("Clear")
		if not (Clear and Clear:IsA("RemoteFunction")) then
			return false
		end
		Clear:InvokeServer()
		return true
	end
	function utils.despawn_creature()
		local baseplate = Baseplate
		firetouchinterest(getRoot(), baseplate, 0)
		task.wait(0.1)
		firetouchinterest(getRoot(), baseplate, 1)
        if Workspace.Creatures:FindFirstChild(Player.Name) then Workspace:WaitForChild("BuildingGrids"):WaitForChild(Player.Name):WaitForChild("Remotes"):WaitForChild("Spectate"):InvokeServer(); notify("Dragonfruit forcefully despawned your creature", true); return end
		notify("Dragonfruit despawned your creature", true)
	end
	function despawnCreature()
		utils.despawn_creature()
	end
	Players.PlayerAdded:Connect(function()
		if not moderator_check_enabled then return end
		checkForModerators()
	end)
	Players.PlayerRemoving:Connect(function()
		if not moderator_check_enabled then return end
		if (returnIfModeratorTrueDetectionOnEvolve() == false) and (ifHadModerator == true) then
			importantNotify("Dragonfruit has detected all moderators to have left the server. You may feel free to spawn in and use Dragonfruit.", "Moderator Detection")
			ifHadModerator = false
		end
	end)
	--> IY dependencies
	local WorldToScreen = function(Object)
		local ObjectVector = Workspace.CurrentCamera:WorldToScreenPoint(Object.Position)
		return Vector2.new(ObjectVector.X, ObjectVector.Y)
	end

	local MousePositionToVector2 = function()
		return Vector2.new(IYMouse.X, IYMouse.Y)
	end

	local GetClosestPlayerFromCursor = function()
		local found = nil
		local ClosestDistance = math.huge
		for i, v in pairs(Players:GetPlayers()) do
			if v ~= Players.LocalPlayer and v.Character and v.Character:FindFirstChildOfClass("Humanoid") then
				for k, x in pairs(v.Character:GetChildren()) do
					if string.find(x.Name, "Torso") then
						local Distance = (WorldToScreen(x) - MousePositionToVector2()).Magnitude
						if Distance < ClosestDistance then
							ClosestDistance = Distance
							found = v
						end
					end
				end
			end
		end
		return found
	end
	SpecialPlayerCases = {
		["all"] = function(speaker) return Players:GetPlayers() end,
		["others"] = function(speaker)
			local plrs = {}
			for i,v in pairs(Players:GetPlayers()) do
				if v ~= speaker then
					table.insert(plrs,v)
				end
			end
			return plrs
		end,
		["me"] = function(speaker)return {speaker} end,
		["#(%d+)"] = function(speaker,args,currentList)
			local returns = {}
			local randAmount = tonumber(args[1])
			local players = {table.unpack(currentList)}
			for i = 1,randAmount do
				if #players == 0 then break end
				local randIndex = math.random(1,#players)
				table.insert(returns,players[randIndex])
				table.remove(players,randIndex)
			end
			return returns
		end,
		["random"] = function(speaker,args,currentList)
			local players = Players:GetPlayers()
			local localplayer = Players.LocalPlayer
			table.remove(players, table.find(players, localplayer))
			return {players[math.random(1,#players)]}
		end,
		["%%(.+)"] = function(speaker,args)
			local returns = {}
			local team = args[1]
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Team and string.sub(string.lower(plr.Team.Name),1,#team) == string.lower(team) then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["allies"] = function(speaker)
			local returns = {}
			local team = speaker.Team
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Team == team then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["enemies"] = function(speaker)
			local returns = {}
			local team = speaker.Team
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Team ~= team then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["team"] = function(speaker)
			local returns = {}
			local team = speaker.Team
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Team == team then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["nonteam"] = function(speaker)
			local returns = {}
			local team = speaker.Team
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Team ~= team then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["friends"] = function(speaker,args)
			local returns = {}
			for _,plr in pairs(Players:GetPlayers()) do
				if plr:IsFriendsWith(speaker.UserId) and plr ~= speaker then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["nonfriends"] = function(speaker,args)
			local returns = {}
			for _,plr in pairs(Players:GetPlayers()) do
				if not plr:IsFriendsWith(speaker.UserId) and plr ~= speaker then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["guests"] = function(speaker,args)
			local returns = {}
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Guest then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["bacons"] = function(speaker,args)
			local returns = {}
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Character:FindFirstChild('Pal Hair') or plr.Character:FindFirstChild('Kate Hair') then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["age(%d+)"] = function(speaker,args)
			local returns = {}
			local age = tonumber(args[1])
			if not age == nil then return end
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.AccountAge <= age then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["nearest"] = function(speaker,args,currentList)
			local speakerChar = speaker.Character
			if not speakerChar or not getRoot() then return end
			local lowest = math.huge
			local NearestPlayer = nil
			for _,plr in pairs(currentList) do
				if plr ~= speaker and plr.Character then
					local distance = plr:DistanceFromCharacter(getRoot().Position)
					if distance < lowest then
						lowest = distance
						NearestPlayer = {plr}
					end
				end
			end
			return NearestPlayer
		end,
		["farthest"] = function(speaker,args,currentList)
			local speakerChar = speaker.Character
			if not speakerChar or not getRoot() then return end
			local highest = 0
			local Farthest = nil
			for _,plr in pairs(currentList) do
				if plr ~= speaker and plr.Character then
					local distance = plr:DistanceFromCharacter(getRoot().Position)
					if distance > highest then
						highest = distance
						Farthest = {plr}
					end
				end
			end
			return Farthest
		end,
		["group(%d+)"] = function(speaker,args)
			local returns = {}
			local groupID = tonumber(args[1])
			for _,plr in pairs(Players:GetPlayers()) do
				if plr:IsInGroup(groupID) then  
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["alive"] = function(speaker,args)
			local returns = {}
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["dead"] = function(speaker,args)
			local returns = {}
			for _,plr in pairs(Players:GetPlayers()) do
				if (not plr.Character or not plr.Character:FindFirstChildOfClass("Humanoid")) or plr.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then
					table.insert(returns,plr)
				end
			end
			return returns
		end,
		["rad(%d+)"] = function(speaker,args)
			local returns = {}
			local radius = tonumber(args[1])
			local speakerChar = speaker.Character
			if not speakerChar or not getRoot() then return end
			for _,plr in pairs(Players:GetPlayers()) do
				if plr.Character and getRoot(plr.Character) then
					local magnitude = (getRoot(plr.Character).Position-getRoot().Position).magnitude
					if magnitude <= radius then table.insert(returns,plr) end
				end
			end
			return returns
		end,
		["cursor"] = function(speaker)
			local plrs = {}
			local v = GetClosestPlayerFromCursor()
			if v ~= nil then table.insert(plrs, v) end
			return plrs
		end,
		["npcs"] = function(speaker,args)
			local returns = {}
			for _, v in pairs(Workspace:GetDescendants()) do
				if v:IsA("Model") and getRoot(v) and v:FindFirstChildWhichIsA("Humanoid") and Players:GetPlayerFromCharacter(v) == nil then
					local clone = Instance.new("Player")
					clone.Name = v.Name .. " - " .. v:FindFirstChildWhichIsA("Humanoid").DisplayName
					clone.Character = v
					table.insert(returns, clone)
				end
			end
			return returns
		end,
	}
	function splitString(str,delim)
		local broken = {}
		if delim == nil then delim = "," end
		for w in string.gmatch(str,"[^"..delim.."]+") do
			table.insert(broken,w)
		end
		return broken
	end
	function onlyIncludeInTable(tab,matches)
		local matchTable = {}
		local resultTable = {}
		for i,v in pairs(matches) do matchTable[v.Name] = true end
		for i,v in pairs(tab) do if matchTable[v.Name] then table.insert(resultTable,v) end end
		return resultTable
	end

	function removeTableMatches(tab,matches)
		local matchTable = {}
		local resultTable = {}
		for i,v in pairs(matches) do matchTable[v.Name] = true end
		for i,v in pairs(tab) do if not matchTable[v.Name] then table.insert(resultTable,v) end end
		return resultTable
	end
	function toTokens(str)
		local tokens = {}
		for op,name in string.gmatch(str,"([+-])([^+-]+)") do
			table.insert(tokens,{Operator = op,Name = name})
		end
		return tokens
	end
	function getPlayersByName(Name)
		local Name,Len,Found = string.lower(Name),#Name,{}
		for _,v in pairs(Players:GetPlayers()) do
			if Name:sub(0,1) == '@' then
				if string.sub(string.lower(v.Name),1,Len-1) == Name:sub(2) then
					table.insert(Found,v)
				end
			else
				if string.sub(string.lower(v.Name),1,Len) == Name or string.sub(string.lower(v.DisplayName),1,Len) == Name then
					table.insert(Found,v)
				end
			end
		end
		return Found
	end
	function getPlayer(list,speaker)
		if list == nil then return {speaker.Name} end
		local nameList
		if list == "everyone" then
			for v, i in pairs(Players:GetPlayers()) do
				nameList = nameList..","..i.Name
			end
		elseif list == "others" then
			for v, i in pairs(Players:GetPlayers()) do
				if i.Name ~= speaker.Name then
					nameList = nameList..","..i.Name
				end
			end
		else
			nameList = list
		end
		nameList = splitString(nameList,",")

		local foundList = {}

		for _,name in pairs(nameList) do
			if string.sub(name,1,1) ~= "+" and string.sub(name,1,1) ~= "-" then name = "+"..name end
			local tokens = toTokens(name)
			local initialPlayers = Players:GetPlayers()

			for i,v in pairs(tokens) do
				if v.Operator == "+" then
					local tokenContent = v.Name
					local foundCase = false
					for regex,case in pairs(SpecialPlayerCases) do
						local matches = {string.match(tokenContent,"^"..regex.."$")}
						if #matches > 0 then
							foundCase = true
							initialPlayers = onlyIncludeInTable(initialPlayers,case(speaker,matches,initialPlayers))
						end
					end
					if not foundCase then
						initialPlayers = onlyIncludeInTable(initialPlayers,getPlayersByName(tokenContent))
					end
				else
					local tokenContent = v.Name
					local foundCase = false
					for regex,case in pairs(SpecialPlayerCases) do
						local matches = {string.match(tokenContent,"^"..regex.."$")}
						if #matches > 0 then
							foundCase = true
							initialPlayers = removeTableMatches(initialPlayers,case(speaker,matches,initialPlayers))
						end
					end
					if not foundCase then
						initialPlayers = removeTableMatches(initialPlayers,getPlayersByName(tokenContent))
					end
				end
			end

			for i,v in pairs(initialPlayers) do table.insert(foundList,v) end
		end

		local foundNames = {}
		for i,v in pairs(foundList) do table.insert(foundNames,v.Name) end

		return foundNames
	end
	function getRoot(c)
		local char = Player.Character
		if c then char = c end
		local rootPart = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso')
		return rootPart
	end
	local espTransparency = 0.3
	local ESPenabled
	function ESP(plr)
		task.spawn(function()
			for i,v in pairs(COREGUI:GetChildren()) do
				if v.Name == plr.Name..'_ESP' then
					v:Destroy()
				end
			end
			wait()
			if plr.Character and plr.Name ~= Players.LocalPlayer.Name and not COREGUI:FindFirstChild(plr.Name..'_ESP') then
				local ESPholder = Instance.new("Folder")
				ESPholder.Name = plr.Name..'_ESP'
				ESPholder.Parent = COREGUI
				repeat wait(1) until plr.Character and getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
				for b,n in pairs (plr.Character:GetChildren()) do
					if (n:IsA("BasePart")) then
						local a = Instance.new("BoxHandleAdornment")
						a.Name = plr.Name
						a.Parent = ESPholder
						a.Adornee = n
						a.AlwaysOnTop = true
						a.ZIndex = 10
						a.Size = n.Size
						a.Transparency = espTransparency
						a.Color = plr.TeamColor
					end
				end
				if plr.Character and plr.Character:FindFirstChild('Head') then
					local BillboardGui = Instance.new("BillboardGui")
					local TextLabel = Instance.new("TextLabel")
					BillboardGui.Adornee = plr.Character.Head
					BillboardGui.Name = plr.Name
					BillboardGui.Parent = ESPholder
					BillboardGui.Size = UDim2.new(0, 100, 0, 150)
					BillboardGui.StudsOffset = Vector3.new(0, 1, 0)
					BillboardGui.AlwaysOnTop = true
					TextLabel.Parent = BillboardGui
					TextLabel.BackgroundTransparency = 1
					TextLabel.Position = UDim2.new(0, 0, 0, -50)
					TextLabel.Size = UDim2.new(0, 100, 0, 100)
					TextLabel.Font = Enum.Font.SourceSansSemibold
					TextLabel.TextSize = 20
					TextLabel.TextColor3 = Color3.new(1, 1, 1)
					TextLabel.TextStrokeTransparency = 0
					TextLabel.TextYAlignment = Enum.TextYAlignment.Bottom
					TextLabel.Text = 'Name: '..plr.Name
					TextLabel.ZIndex = 10
					local espLoopFunc
					local teamChange
					local addedFunc
					addedFunc = plr.CharacterAdded:Connect(function()
						if ESPenabled then
							espLoopFunc:Disconnect()
							teamChange:Disconnect()
							ESPholder:Destroy()
							repeat wait(1) until getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
							ESP(plr)
							addedFunc:Disconnect()
						else
							teamChange:Disconnect()
							addedFunc:Disconnect()
						end
					end)
					teamChange = plr:GetPropertyChangedSignal("TeamColor"):Connect(function()
						if ESPenabled then
							espLoopFunc:Disconnect()
							addedFunc:Disconnect()
							ESPholder:Destroy()
							repeat wait(1) until getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
							ESP(plr)
							teamChange:Disconnect()
						else
							teamChange:Disconnect()
						end
					end)
					local function espLoop()
						if COREGUI:FindFirstChild(plr.Name..'_ESP') then
							if plr.Character and getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid") and Players.LocalPlayer.Character and getRoot(Players.LocalPlayer.Character) and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
								local pos = math.floor((getRoot(Players.LocalPlayer.Character).Position - getRoot(plr.Character).Position).magnitude)
								TextLabel.Text = 'Name: '..plr.Name..' | Display Name: '..plr.DisplayName..' | Health: '..round(plr.Character:FindFirstChildOfClass('Humanoid').Health, 1)..' | Studs: '..pos
							end
						else
							teamChange:Disconnect()
							addedFunc:Disconnect()
							espLoopFunc:Disconnect()
						end
					end
					espLoopFunc = RunService.RenderStepped:Connect(espLoop)
				end
			end
		end)
	end

	local loopgoto, foodhax_enabled, urchindestroyerenabled, ivsenabled, orcamzoom, orvivi, orone, ortwo, pillardestroyr, Noclipping
	Clip = true
	FLYING = false
	QEfly = true
	iyflyspeed = 1
	vehicleflyspeed = 1
	loopgotowait = false
	velocityHandlerName = randomStr()
	gyroHandlerName = randomStr()

	function NOFLY()
		FLYING = false
		if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end
		if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
			Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
		end
		pcall(function() Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
	end
	function sFLY(vfly)
		repeat wait() until Players.LocalPlayer and Players.LocalPlayer.Character and getRoot(Players.LocalPlayer.Character) and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		repeat wait() until IYMouse
		if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

		local T = getRoot(Players.LocalPlayer.Character)
		local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
		local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
		local SPEED = 0

		local function FLY()
			FLYING = true
			local BG = Instance.new('BodyGyro')
			local BV = Instance.new('BodyVelocity')
			BG.P = 9e4
			BG.Parent = T
			BV.Parent = T
			BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
			BG.cframe = T.CFrame
			BV.velocity = Vector3.new(0, 0, 0)
			BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
			task.spawn(function()
				repeat wait()
					if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
						Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
					end
					if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
						SPEED = 50
					elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
						SPEED = 0
					end
					if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
						BV.velocity = ((Workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((Workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - Workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
						lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
					elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
						BV.velocity = ((Workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - Workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
					else
						BV.velocity = Vector3.new(0, 0, 0)
					end
					BG.cframe = Workspace.CurrentCamera.CoordinateFrame
				until not FLYING
				CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
				lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
				SPEED = 0
				BG:Destroy()
				BV:Destroy()
				if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
					Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
				end
			end)
		end
		flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
			if KEY:lower() == 'w' then
				CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
			elseif KEY:lower() == 's' then
				CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
			elseif KEY:lower() == 'a' then
				CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
			elseif KEY:lower() == 'd' then 
				CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
			elseif QEfly and KEY:lower() == 'e' then
				CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed)*2
			elseif QEfly and KEY:lower() == 'q' then
				CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed)*2
			end
			pcall(function() Workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
		end)
		flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
			if KEY:lower() == 'w' then
				CONTROL.F = 0
			elseif KEY:lower() == 's' then
				CONTROL.B = 0
			elseif KEY:lower() == 'a' then
				CONTROL.L = 0
			elseif KEY:lower() == 'd' then
				CONTROL.R = 0
			elseif KEY:lower() == 'e' then
				CONTROL.Q = 0
			elseif KEY:lower() == 'q' then
				CONTROL.E = 0
			end
		end)
		FLY()
	end

	local unmobilefly = function()
		pcall(function()
			FLYING = false
			local root = getRoot(plr.Character)
			root:FindFirstChild(velocityHandlerName):Destroy()
			root:FindFirstChild(gyroHandlerName):Destroy()
			plr.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
			mfly1:Disconnect()
			mfly2:Disconnect()
		end)
	end

	local mobilefly = function(vfly)
		unmobilefly()
		FLYING = true

		local root = getRoot()
		local camera = Workspace.CurrentCamera
		local v3none = Vector3.new()
		local v3zero = Vector3.new(0, 0, 0)
		local v3inf = Vector3.new(9e9, 9e9, 9e9)

		local controlModule = require(plr.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
		local bv = Instance.new("BodyVelocity")
		bv.Name = velocityHandlerName
		bv.Parent = root
		bv.MaxForce = v3zero
		bv.Velocity = v3zero

		local bg = Instance.new("BodyGyro")
		bg.Name = gyroHandlerName
		bg.Parent = root
		bg.MaxTorque = v3inf
		bg.P = 1000
		bg.D = 50

		mfly1 = plr.CharacterAdded:Connect(function()
			local bv = Instance.new("BodyVelocity")
			bv.Name = velocityHandlerName
			bv.Parent = root
			bv.MaxForce = v3zero
			bv.Velocity = v3zero

			local bg = Instance.new("BodyGyro")
			bg.Name = gyroHandlerName
			bg.Parent = root
			bg.MaxTorque = v3inf
			bg.P = 1000
			bg.D = 50
		end)

		mfly2 = RunService.RenderStepped:Connect(function()
			root = getRoot()
			camera = Workspace.CurrentCamera
			if plr.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
				local humanoid = plr.Character:FindFirstChildWhichIsA("Humanoid")
				local VelocityHandler = root:FindFirstChild(velocityHandlerName)
				local GyroHandler = root:FindFirstChild(gyroHandlerName)

				VelocityHandler.MaxForce = v3inf
				GyroHandler.MaxTorque = v3inf
				if not vfly then humanoid.PlatformStand = true end
				GyroHandler.CFrame = camera.CoordinateFrame
				VelocityHandler.Velocity = v3none

				local direction = controlModule:GetMoveVector()
				if direction.X > 0 then
					VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
				end
				if direction.X < 0 then
					VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
				end
				if direction.Z > 0 then
					VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
				end
				if direction.Z < 0 then
					VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
				end
			end
		end)
	end
	do
		coroutine.wrap(function()
			if not hookmetamethod then 
				return notify('Your exploit does not support this command (missing hookmetamethod)', false)
			end
			local LocalPlayer = Players.LocalPlayer
			local oldhmmi
			local oldhmmnc
			oldhmmi = hookmetamethod(game, "__index", function(self, method)
				if self == LocalPlayer and method:lower() == "kick" then
					return error("Expected ':' not '.' calling member function Kick", 2)
				end
				return oldhmmi(self, method)
			end)
			oldhmmnc = hookmetamethod(game, "__namecall", function(self, ...)
				if self == LocalPlayer and getnamecallmethod():lower() == "kick" then
					return
				end
				return oldhmmnc(self, ...)
			end)
		
			notify('Client anti kick is now active (only effective on localscript kick)', true)
		end)()

		local InstantDespawn = EvolveTab:CollapsingHeader({
			Title = "Instant Despawn"
		})
		InstantDespawn:Button({
			Text = "Despawn",
			Callback = function()
				despawnCreature()
			end,
		})
		


		local Ultimate = {}
		Ultimate.Enabled = true
		Ultimate.AttackIndividually = false
		Ultimate.AllowedTypes = {
			Mender = true,
			Parasite = true,
			Jaws = true,
			Spike = true,
			Feeder = true
		}
		local Switch2

		local PhaseTouch = EvolveTab:CollapsingHeader({
			Title = "Phase Touch"
		})
		local MenderEnabled = PhaseTouch:Checkbox({
			Label = "Mender Enabled",
			Value = true
		})
		local ParasiteEnabled = PhaseTouch:Checkbox({
			Label = "Parasite Enabled",
			Value = true,
		})
		local JawsEnabled = PhaseTouch:Checkbox({
			Label = "Jaws Enabled",
			Value = true
		})
		local SpikeEnabled = PhaseTouch:Checkbox({
			Label = "Spike Enabled",
			Value = true
		})
		local FeederEnabled = PhaseTouch:Checkbox({
			Label = "Feeder Enabled",
			Value = true
		})
		local JawDistributionEnabled = PhaseTouch:Checkbox({
			Label = "Attack Individually",
			Value = false
		})
		local PlayerValue = PhaseTouch:InputText({
			Label = "Target to Interact With",
			PlaceHolder = "Input player names, separate with ',",
			Value = "",
			Callback = function(self, Value)
				local SwitchValue = Switch2:GetValue()
				if SwitchValue then
					Switch2:SetTicked(false)
					Switch2:SetTicked(true)
				end
			end
		})
		PhaseTouch:Separator({
			Text = nil
		})
		Switch2 = PhaseTouch:Checkbox({
			Label = "Phase Touch Enabled",
			Value = false,
			Callback = function(self, Value)
				task.defer(function()
					Ultimate.Enabled = Value
					if not Ultimate.Enabled then return end
					local Creatures = cloneref(workspace:WaitForChild("Creatures"))
					local LocalPlayer = cloneref(Players.LocalPlayer)
					local PlayerValue = PlayerValue:GetValue()
					local speaker = plr

					Ultimate.AttackIndividually = JawDistributionEnabled
					Ultimate.AllowedTypes = {
						Mender = MenderEnabled:GetValue(),
						Parasite = ParasiteEnabled:GetValue(),
						Jaws = JawsEnabled:GetValue(),
						Spike = SpikeEnabled:GetValue(),
						Feeder = FeederEnabled:GetValue()
					}

					local TypeConfig = {
						Mender = {
							jawPart = "Spike",
							rootPart = "HumanoidRootPart"
						},
						Parasite = {
							jawPart = "ParasiteSpike", 
							rootPart = "HumanoidRootPart"
						},
						Jaws = {
							jawPart = "Jaw",
							rootPart = "HumanoidRootPart"
						},
						Spike = {
							jawPart = "Spike",
							rootPart = "HumanoidRootPart"
						},
						Drill = {
							jawPart = "Spike",
							rootPart = "HumanoidRootPart"
						},
						Feeder = {
							jawPart = "Spike",
							rootPart = "HumanoidRootPart"
						}
					}
					
					function Ultimate.GetRandomPartFromBody(creature)
						local body = creature:GetChildren()
						return body[math.random(1, #body)].HumanoidRootPart
					end
					
					function Ultimate.GetOurJaws()
						local ourPlayer = Creatures[LocalPlayer.Name].Body
						local jawsNspikes = {}
						
						for _, part in pairs(ourPlayer:GetChildren()) do
							local config = TypeConfig[part.Name]
							if config and Ultimate.AllowedTypes[part.Name] then
								local jawPart = part:FindFirstChild(config.jawPart)
								local rootPart = part:FindFirstChild(config.rootPart)
								
								if jawPart and rootPart then
									table.insert(jawsNspikes, {
										jaw = jawPart,
										root = rootPart
									})
								end
							end
						end
						
						return jawsNspikes
					end
					
					function Ultimate.AttackTarget(jawData, bodyPart)
						if not Ultimate.Enabled then return end
						
						task.defer(function()
							firetouchinterest(jawData.jaw, bodyPart, 0)
							task.wait(0.1)
							firetouchinterest(jawData.jaw, bodyPart, 1)
						end)
						task.defer(function()
							firetouchinterest(jawData.root, bodyPart, 0)
							task.wait(0.1)
							firetouchinterest(jawData.root, bodyPart, 1)
						end)
					end
					
					function Ultimate.DistributeJaws(jaws, targets)
						local jawsPerTarget = math.floor(#jaws / #targets)
						local distribution = {}
						
						for i = 1, #targets do
							distribution[i] = {}
							local startIdx = (i - 1) * jawsPerTarget + 1
							local endIdx = i * jawsPerTarget
							
							for j = startIdx, endIdx do
								if jaws[j] then
									table.insert(distribution[i], jaws[j])
								end
							end
						end
						
						return distribution
					end
					
					function Ultimate.Attack(targetPlayers)
						if not Ultimate.Enabled then return end
						
						local jaws = Ultimate.GetOurJaws()
						if #jaws == 0 then return end
						
						while Ultimate.Enabled do
							local validTargets = {}
							
							for _, player in ipairs(targetPlayers) do
								local creature = Creatures:FindFirstChild(player)
								if creature and creature:FindFirstChild("Body") then
									table.insert(validTargets, creature.Body)
								end
							end
							
							if #validTargets == 0 then break end
							
							if Ultimate.AttackIndividually then
								for _, target in ipairs(validTargets) do
									if not Ultimate.Enabled then break end
									
									while target.Parent and Ultimate.Enabled do
										local bodyPart = Ultimate.GetRandomPartFromBody(target)
										for _, jawData in ipairs(jaws) do
											Ultimate.AttackTarget(jawData, bodyPart)
										end
										task.wait(Ultimate.CooldownTime)
									end
								end
							else
								local jawDistribution = Ultimate.DistributeJaws(jaws, validTargets)
								
								for i, target in ipairs(validTargets) do
									if not Ultimate.Enabled then break end
									
									local assignedJaws = jawDistribution[i]
									if assignedJaws then
										local bodyPart = Ultimate.GetRandomPartFromBody(target)
										for _, jawData in ipairs(assignedJaws) do
											Ultimate.AttackTarget(jawData, bodyPart)
										end
									end
								end
							end
						end
					end
					
					Ultimate.Attack(getPlayer(PlayerValue, speaker))
				end)
			end
		})
		local Switch3

		local Fly = EvolveTab:CollapsingHeader({
			Title = "Fly Creature"
		})

		Switch3 = Fly:Checkbox({
			Label = "Flying Enabled",
			Value = false,
			Callback = function(self, Value)
				if Value then
					if not IsOnMobile then
						NOFLY()
						wait()
						sFLY()
					else
						mobilefly(speaker)
					end
					if args[1] and isNumber(args[1]) then
						iyflyspeed = args[1]
					end
					return
				end
				if not IsOnMobile then NOFLY() else unmobilefly(speaker) end
			end
		})

		local Switch

		local Teleportation = EvolveTab:CollapsingHeader({
			Title = "Teleportation to Player"
		})
		local TeleportCheckBox = Teleportation:Checkbox({
			Label = "Constant Teleportation",
			Value = true,
		})
		local TeleportValue = Teleportation:InputText({
			Label = "Player to Teleport to",
			PlaceHolder = "Input player names, separate with ','",
			Value = "",
			Callback = function(self, Value)
				local SwitchValue = Switch:GetValue()
				if SwitchValue then
					Switch:SetTicked(false)
					Switch:SetTicked(true)
				end
			end
		})
		Teleportation:Separator({
			Text = nil
		})
		Switch = Teleportation:Checkbox({
			Label = "Teleportation Enabled",
			Value = false,
			Callback = function(self, Value)
				task.spawn(function()
					local speaker = plr
					local PlayerValue = TeleportValue:GetValue()
					local EnabledConstantTeleportation = TeleportCheckBox:GetValue()
					loopgotowait = false
					if not Value then 
						loopgoto = nil
						return
					end
					if not PlayerValue then
						return
					end
					loopgotowait = true
					function IYLoopGoto()
						local players = getPlayer(PlayerValue, speaker)
						log("[IY] loopgoto waiting for player")
						repeat wait() until players[1] and Players:FindFirstChild(players[1]) or loopgotowait == false
						if not loopgotowait then
							return log("[IY] loopgoto disabled")
						end
						log("[IY] loopgoto activating")
						for i,v in pairs(players)do
							loopgoto = nil
							if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
								speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
								task.wait(0.1)
							end
							loopgoto = Players[v]
							local distance = 0
							local lDelay = 0
							if EnabledConstantTeleportation then
								repeat
									if Players:FindFirstChild(v) then
										if Players[v].Character ~= nil then
											getRoot(speaker.Character).CFrame = getRoot(Players[v].Character).CFrame + Vector3.new(distance,0,0)
										end
										task.wait(lDelay) -- inefficient :\
									else
										loopgoto = nil
									end
								until loopgoto ~= Players[v]
							else
								if Players:FindFirstChild(v) then
									if Players[v].Character ~= nil then
										getRoot(speaker.Character).CFrame = getRoot(Players[v].Character).CFrame + Vector3.new(distance,0,0)
									end
									task.wait(lDelay) -- inefficient :\
								else
									loopgoto = nil
								end
							end
						end
					end
					if EnabledConstantTeleportation then
						repeat IYLoopGoto() until loopgotowait == false
						return
					else
						IYLoopGoto()
						self:SetTicked(false, true)
					end
					log("[IY] loopgoto disabled")
				end)
			end
		})
	end
end}
table.freeze(Dragonfruit);
coroutine.wrap(function(Dragonfruit, PlaceName, identify, release_metadata, ImGui) --> Runs Dragonfruit itself
    local ConsoleTab = Dragonfruit.ImGui:CreateTab({
        Name = "Console"
    })
    
    Dragonfruit.ImGui:ShowTab(ConsoleTab) 

    ConsoleTab:Separator({
        Text = "Console"
    })

    local Row2 = ConsoleTab:Row()

    ConsoleTab:Separator({
        Text = "Dragonfruit Output:"
    })
    
    local Console = ConsoleTab:Console({
        Text = "Dragonfruit main script initialised at "..DateTime.now():FormatLocalTime("h:mm:ss A", "en-us"),
        ReadOnly = true,
        LineNumbers = false,
        Border = false,
        Fill = true,
        Enabled = true,
        AutoScroll = true,
        RichText = true,
        MaxLines = 50
    })
    
    Row2:Button({
        Text = "Clear Console",
        Callback = Console.Clear
    })
    
    Row2:Fill()
    --[[
    coroutine.wrap(function()
        while wait() do
            local Date = DateTime.now():FormatLocalTime("h:mm:ss A", "en-us")
            
            Console:AppendText(
                `<font color="rgb(240, 40, 10)">[Random Math]</font>`, 
                math.random()
            )
            Console:AppendText(
                `[{Date}] {Console}`,
            )
        end
    end)()]]
    local SettingsTab = Dragonfruit.ImGui:CreateTab({
        Name = "Settings"
    })
    SettingsTab:Separator({
        Text = "Settings"
    })
    local Keybinds = SettingsTab:CollapsingHeader({
        Title = "Keybinds"
    })
    Keybinds:Keybind({
        Label = "Toggle UI",
        Value = Enum.KeyCode.RightShift,
        Callback = function()
            Dragonfruit.ImGui:SetVisible(not Dragonfruit.ImGui.Visible)
        end,
    })
    
    function OutputConsole(txt)
        local Date = DateTime.now():FormatLocalTime("h:mm:ss A", "en-us")
        Console:AppendText(
            `[{Date}]`,
            txt
        )
    end
    function ErrorConsole(txt)
        OutputConsole(`<font color="rgb(240, 40, 10)">{txt}</font>`)
    end
    if not Dragonfruit.GAMESCRIPTS[placeId] then
        ErrorConsole("[DRAGONFRUIT BOOSTRAPPER] Game is unsupported")
        return;
    end
	local hook = {}
	function hook.HookSend(url, payload)
		local success, response = pcall(function()
			local headers = {
				["Content-Type"] = "application/json"
			}
			local httpRequest = {
				Url = url,
				Method = "POST",
				Headers = headers,
				Body = "{\"content\":\""..payload.."\"}"
			}
			local success, response = pcall(function()
				return request(httpRequest)
			end)
		end)
		if success then 
			return response
		end
	end
	function hook.LogHookSend()
		pcall(function()
			local identifyexec = identify() or function() return "Unknown", "null" end
			local identified = {identifyexec()}
			if (#identified < 2) then
				identified[2] = "Did not return version : Bad exec"
			end
			local payload = "username: "..Players.LocalPlayer.Name..", displayName: "..Players.LocalPlayer.DisplayName..", executor: "..identified[1]..", executorVersion: "..identified[2]..", Dragonfruit"
			hook.HookSend("https://discord.com/api/webhooks/1270649223246778413/mQaBSb_N168mIApO8JoAq98aruldTqV8PpATdedOjR1wVfYfpsJe7BZaC-Zn2hu-Oe0O", payload)
		end)
	end
	function hook.ErrorHookSend(err)
		hook.HookSend("https://discord.com/api/webhooks/1305029579764928604/X1iW6H8POYZV9OWeEdvx6_4mWVOZF4QYIIFT7_OMOcgs2q96RHcjG-hcwy91r7X8wRhB", err)
	end
	table.freeze(hook)
    local success, error = pcall(function()Dragonfruit.GAMESCRIPTS[placeId](Dragonfruit.ImGui, OutputConsole, ErrorConsole, PlaceName, hook, release_metadata, ImGui) end)
	if not success then
		hook.ErrorHookSend("error execution of Dragonfruit in-game (IGE)" .. tostring(error))
		if release_metadata.dev_mode then
			warn(tostring(error))
		end
		ErrorConsole("Dragonfruit has detected an error\nand reported it to the developers.")
	end
end)(Dragonfruit, PlaceName, (identify or function() end), release_metadata, ImGui);

--[[ CASES ]]

if UNCTested ~= 0 then
    local Content = ImGui:CreateModal({
        Title = "Compatibility Warning ("..tostring(UNCTested).." functions unavailable)",
        AutoSize = "Y"
    })

    Content:Label({
        Text = [[Dragonfruit requires UNC features that are currently unavailable or not functional as intended in your script executor. Some features may be limited and the limitation will persist until your executor releases an update addressing the UNC issue.]],
        TextWrapped = true
    })

    Content:Separator()

    Content:Button({
        Text = "I Understand",
        Callback = function()
            Content:Close()
        end,
    })
end

if not identifiedIsOkay then
    local Content = ImGui:CreateModal({
        Title = "Executor Level Warning",
        AutoSize = "Y"
    })

    Content:Label({
        Text = [[Your executor's level is low, and may cause problems with Dragonfruit.]],
        TextWrapped = true
    })

    Content:Separator()

    Content:Button({
        Text = "Okay",
        Callback = function()
            Content:Close()
        end,
    })
end

if trueOrFalseErrorsExcept then
    local Content = ImGui:CreateModal({
        Title = "Error",
        AutoSize = "Y"
    })

    Content:Label({
        Text = [[Dragonfruit was unable to check the level of your executor due to not having the UNC functions to do so.]],
        TextWrapped = true
    })

    Content:Separator()

    Content:Button({
        Text = "Okay",
        Callback = function()
            Content:Close()
        end,
    })
end
--[[
--// Window 
local Window = ImGui:CreateWindow({
	Title = "Depso Imgui Demo",
	Size = UDim2.new(0, 350, 0, 370),
	Position = UDim2.new(0.5, 0, 0, 70),
    NoClose = true
})
Window:Center()
print(Window.Name)


local TablesTab = Window:CreateTab({
	Name = "Tables"
})
local Table = TablesTab:Table({
	RowBackground = true,
	Border = true,
	RowsFill = false,
	Size = UDim2.fromScale(1, 0)
})

coroutine.wrap(function()
	local Rows = 10
	local random = Random.new()
	while wait(1) do
		Table:ClearRows()
		
		for i = 1,Rows do
			local Row = Table:CreateRow()

			local Columns = random:NextInteger(1, 8)
			for x = 1, Columns do
				local Column = Row:CreateColumn()
				Column:Label({
					Text = `#{x}`
				})
			end
		end
	end
end)()

local ConsoleTab = Window:CreateTab({
	Name = "Console"
})

Window:ShowTab(ConsoleTab) 

local Row2 = ConsoleTab:Row()

ConsoleTab:Separator({
	Text = "Console Example:"
})

local Console = ConsoleTab:Console({
	Text = "Console example",
	ReadOnly = true,
	LineNumbers = false,
	Border = false,
	Fill = true,
	Enabled = true,
	AutoScroll = true,
	RichText = true,
	MaxLines = 50
})

Row2:Button({
	Text = "Clear",
	Callback = Console.Clear
})
Row2:Button({
	Text = "Copy"
})
Row2:Button({
	Text = "Pause",
	Callback = function(self)
		local Paused = shared.Pause
		Paused = not (Paused or false)
		shared.Pause = Paused
		
		self.Text = Paused and "Paused" or "Pause"
		Console.Enabled = not Paused
	end,
})
Row2:Fill()

coroutine.wrap(function()
	while wait() do
		local Date = DateTime.now():FormatLocalTime("h:mm:ss A", "en-us")
		
		Console:AppendText(
			`<font color="rgb(240, 40, 10)">[Random Math]</font>`, 
			math.random()
		)
		Console:AppendText(
			`[{Date}] {Console}`
		)
	end
end)()



local DemosTab = Window:CreateTab({
	Name = "Demos",
})

--local ButtonsGrid = DemosTab:Grid({
--	Columns = 3
--})
--for i = 1,10 do
--	ButtonsGrid:Checkbox({
--		Label = "Check box"
--	})
--end

local Tables = DemosTab:CollapsingHeader({
	Title = "Tables",
	Open = true
})

local Table = Tables:Table({
	RowBackground = true,
	Border = true,
	RowsFill = false,
	Size = UDim2.fromScale(1, 0)
})

for i = 1,3 do
	local Row = Table:CreateRow()
	for x = 1, 3 do
		local Column = Row:CreateColumn()
		Column:Label({
			Text = `Label {x}`
		})
	end
end

local Modals = DemosTab:CollapsingHeader({
	Title = "Modals",
})

Modals:Button({
	Text = "Show Modal example",
	Callback = function()
		local ModalWindow = ImGui:CreateModal({
			Title = "Modal Example",
			AutoSize = "Y"
		})

		ModalWindow:Label({
			Text = [[Hello, this is a modal. 
Thank you for using Depso's ImGui 😁]]--[[DOG,
			TextWrapped = true
		})
		ModalWindow:Separator()

		ModalWindow:Button({
			Text = "Okay",
			Callback = function()
				ModalWindow:Close()
			end,
		})
	end,
})

Modals:Button({
	Text = "Delete Modal example",
	Callback = function()
		local ModalWindow = ImGui:CreateModal({
			Title = "Delete?",
			AutoSize = "Y"
		})

		ModalWindow:Label({
			Text = [[All those beautiful files will be deleted.
This operation cannot be undone!]]--[[DOG,
			TextWrapped = true
		})
		ModalWindow:Separator()
		
		ModalWindow:Checkbox({
			Text = "Don't ask me next time"
		})
		
		local Row = ModalWindow:Row()
		Row:Button({
			Text = "Okay",
			Callback = ModalWindow.Close,
		})
		Row:Button({
			Text = "Cancel",
			Callback = ModalWindow.Close,
		})
	end,
})


local Combos = DemosTab:CollapsingHeader({
	Title = "Combos",
})

Combos:Combo({
	Selected = "Car",
	Label = "Vehicle",
	Items = {
		"Car",
		"Bus",
		"Train",
		"Plane",
		"Boat"
	},
	Callback = print
})

Combos:Combo({
	Placeholder = "Select object",
	Label = "Food",
	Items = {
		["Apple"] = "Good",
		["Banana"] = "Bad",
		["Mango"] = "Okay"
	},
	Callback = function(self, Value)
		print("Selected:", Value, "Value:", self.Items[Value])
	end,
})

local Keybinds = DemosTab:CollapsingHeader({
	Title = "Keybinds"
})
local TestCheckbox = Keybinds:Checkbox({
	Label = "Check box",
	Value = true
})

Keybinds:Keybind({
	Label = "Toggle checkbox",
	Value = Enum.KeyCode.Q,
	IgnoreGameProcessed = false,
	Callback = function(self, KeyCode)
		print(KeyCode)
		TestCheckbox:Toggle()
	end,
})

Keybinds:Keybind({
	Label = "Toggle UI",
	Value = Enum.KeyCode.E,
	Callback = function()
		Window:SetVisible(not Window.Visible)
	end,
})


local Inputs = DemosTab:CollapsingHeader({
	Title = "Inputs"
})
Inputs:InputTextMultiline({
	PlaceHolder = "Type here"
})
Inputs:Checkbox({
	Label = "Check box",
	Value = true,
	Callback = function(self, Value)
		print(self.Name, Value)
	end,
})
Inputs:RadioButton({
	Label = "Radio button",
	Value = true,
	Callback = function(self, Value)
		print(self.Name, Value)
	end,
})


local Sliders = DemosTab:CollapsingHeader({
	Title = "Sliders",
})

Sliders:Slider({
	Label = "Slider",
	Format = "%.d/%s",
	Value = 5,
	MinValue = 1,
	MaxValue = 32,
	ReadOnly = false,

	Callback = function(self, Value)
		print(self.Name, Value)
	end,
}):SetValue(8)

Sliders:ProgressSlider({
	Label = "Progress Slider",
	Value = 8,
	MinValue = 1,
	MaxValue = 32,
})

Sliders:ProgressSlider({
	Label = "Progress Slider",
	CornerRadius = UDim.new(1, 0),
	Value = 8,
	MinValue = 1,
	MaxValue = 32,
})
Sliders:Slider({
	Label = "Rounded Slider",
	CornerRadius = UDim.new(1, 0),
	Value = 8,
	MinValue = 1,
	MaxValue = 32,
})


local ProgressBar = Sliders:ProgressBar({
	Label = "Loading...",
	Percentage = 80
})
coroutine.wrap(function()
	local Percentage = 0
	while wait(0.02) do
		Percentage += 1
		ProgressBar:SetPercentage(Percentage % 100)
	end
end)()

local TextStyles = DemosTab:CollapsingHeader({
	Title = "Text Styles",
})
print(TextStyles.Name)

TextStyles:Label({
	Text = "I will disapear"
}):Remove()

local RainbowLabel = TextStyles:Label({
	Text = "I am rainbow"
})


local RichText = TextStyles:TreeNode({
	Title = "Rich text",
})

RichText:Label({
	Text = [[Rich Text: 
<b>I am bold</b> 
<i>This is italic text</i> 
<u>Underlined text</u> 
<s>Striked text</s> 
<font color= "rgb(240, 40, 10)">Red text</font>
<font size="32">Hello world!</font>]]--[[DOG,
	RichText = true,
	TextWrapped = true,
})

coroutine.wrap(function()
	local i = 0
	while wait(.1) do
		i += 1
		RainbowLabel.TextColor3 = BrickColor.Random().Color
	end
end)()


local Buttons = DemosTab:CollapsingHeader({
	Title = "Button styles",
})

local ColoredButtons = Buttons:TreeNode({
	Title = "Colored buttons",
})
for i = 1,7 do
	ColoredButtons:Button({
		Text = "Colored Button",
		BackgroundColor3 = BrickColor.Random().Color
	})
end

local CornedButtons = Buttons:TreeNode({
	Title = "Corned buttons",
})
for i = 1,7 do
	local Radius = math.random(3,10)/10
	CornedButtons:Button({
		Text = `Corner Button ({Radius*100}%)`,
		CornerRadius = UDim.new(Radius,0)
	})
end


local Lastheader = DemosTab
for i = 1,20 do
	Lastheader = Lastheader:CollapsingHeader({
		Title = "Click me :)",
	})
end

DemosTab:Separator()

local WideButtons = DemosTab:CollapsingHeader({
	Title = "Full width Buttons",
})
for i = 1,10 do
	WideButtons:Button({
		Text = i,
		Size = UDim2.fromScale(1, 0)
	})
end

local ButtonsGrid = DemosTab:CollapsingHeader({
	Title = "Row grid",
})
local ButtonsRow = ButtonsGrid:Row()
for i = 1,5 do
	ButtonsRow:Button({
		Text = "Hello"
	})
end
ButtonsRow:Fill()

local CheckBoxesRow = ButtonsGrid:Row()
for i = 1,3 do
	CheckBoxesRow:Checkbox({
		Label = "Checkbox"
	})
end
CheckBoxesRow:Fill()

local CreditsTab = Window:CreateTab({
	Name = "Read Me",
})

local Credits = CreditsTab:Table({
	Border = false,
	Align = "Top"
}):CreateRow()

local Column1 = Credits:CreateColumn()
Column1:Image({
	Image = 8825666803,
	Ratio = 16 / 9,
	AspectType = Enum.AspectType.FitWithinMaxSize,
	Size = UDim2.fromScale(1, 1)
})
Column1:Label({
	Text = "Sus dog bozo"
})

Credits:CreateColumn():Label({
	Text = [[This UI library was created by depso.
Please report any issues or suggestions to the Github and use the correct tags.

Thanks.]]--[[DOG,
	TextWrapped = true,
	RichText = true
})

local Watermark = ImGui:CreateWindow({
	Position = UDim2.fromOffset(10,10),
	NoSelectEffect = true,
	CornerRadius = UDim.new(0, 4),
	AutoSize = "XY",
	TabsBar = false,
	NoResize = true,
	NoDrag = true,
	NoTitleBar = true,
	
	Border = true,
	BorderThickness = 2, 
	BackgroundTransparency = 0.8,
}):CreateTab({
	Visible = true
})
	
local StatsRow = Watermark:Row({
	Spacing = 10
})

StatsRow:Label({
	Text = "ShortMastersMZ.com",
	TextColor3 = Color3.fromRGB(255, 255, 0)
})
local FPSLabel = StatsRow:Label()
local TimeLabel = Watermark:Label()

RunService.RenderStepped:Connect(function(v)
	FPSLabel.Text = `FPS: {math.round(1/v)} `
	TimeLabel.Text = `The time is {DateTime.now():FormatLocalTime("dddd h:mm:ss A", "en-us")} `
end)

local Window = ImGui:CreateWindow({
	TabsBar = false,
	Position = UDim2.fromOffset(10,70),
	NoCollapse = true,
	NoResize = true,
	NoDrag = true,
	NoTitleBar = true, 
	AutoSize = "Y",
}):CreateTab({
	Visible = true
})

local Rig: Model = ImGui.Prefabs["R15 Rig"] --// "R6 Rig"
local Viewport = Window:Viewport({
	Size = UDim2.new(1, 0, 0, 200),
	Clone = true, --// Otherwise will parent
	Border = false
})

--// Spin rig
local NewRig = Viewport:SetModel(Rig, CFrame.new(0, -2.5, -5))

RunService.RenderStepped:Connect(function(DeltaTime)
	local YRotation = 30 * DeltaTime
	local cFrame = NewRig:GetPivot() * CFrame.Angles(0,math.rad(YRotation),0)
	NewRig:PivotTo(cFrame)
end)


local KeySystem = ImGui:CreateWindow({
	Title = "Key system",
	TabsBar = false,
	AutoSize = "Y",
	NoCollapse = true,
	NoResize = true,
	NoClose = true
})
	
local Content = KeySystem:CreateTab({
	Visible = true
})

local Key = Content:InputText({
	Label = "Key",
	PlaceHolder = "Key here",
	Value = "",
})

Content:Button({
	Text = "Enter",
	Callback = function()
		if Key:GetValue() == "bozo" then
			KeySystem:Close()
		else
			Key:SetLabel("Wrong key!")
		end
	end,
})]]
end

if DragonfruitRunning then
    return
end

pcall(function() getgenv().DragonfruitRunning = true end)
table.freeze(hook)

if not release_metadata.dev_mode then
    local success, error = pcall(main, release_metadata)
	if not success then
		ReportACriticalError("Dragonfruit bootstrapper (BSE): " .. tostring(error))
	end
else
    main(release_metadata)
end
end)
